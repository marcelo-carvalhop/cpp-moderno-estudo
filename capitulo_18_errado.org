* Capítulo 18: Organização de Código — Do Pré-processador aos Módulos do C++20

Até agora, todos os nossos exemplos foram autocontidos em um único arquivo. No mundo real, projetos são divididos em dezenas, centenas ou milhares de arquivos para gerenciar a complexidade, permitir o trabalho em equipe e facilitar a reutilização de código. Este capítulo explora as duas principais estratégias para organizar código em C++: o modelo clássico baseado no pré-processador e o moderno paradigma de módulos.

** 18.1 O Modelo Clássico: Headers e Arquivos de Implementação

O método tradicional, usado por décadas, divide uma unidade lógica de código (como uma classe) em dois arquivos:

  1. Arquivo de Cabeçalho (Header File - .h, .hpp): Contém as declarações. É a interface pública da sua unidade de código. Ele diz ao resto do programa "o que" existe: declarações de classes, assinaturas de funções, etc. Este arquivo é incluído por outros arquivos que desejam usar essa funcionalidade.

  2. Arquivo de Implementação (Source File - .cpp): Contém as definições. É aqui que o código dos métodos declarados no header é efetivamente escrito. Ele diz "como" a funcionalidade é implementada. Este arquivo é compilado separadamente.

A diretiva #include é o elo que une tudo. No entanto, é crucial entender que #include é uma operação do pré-processador. É uma cópia e cola textual. Quando o compilador vê #include "meu_header.hpp", ele literalmente substitui essa linha por todo o conteúdo do arquivo meu_header.hpp antes de iniciar a compilação de fato.

Isso leva a um problema: se múltiplos arquivos .cpp incluem o mesmo header, e esse header por sua vez inclui outros, o mesmo header pode ser colado várias vezes no mesmo arquivo de compilação, violando a "One Definition Rule" (ODR) e causando erros.

A solução para isso são os Include Guards:

#+begin_src cpp
// Dentro de "minha_classe.hpp"

#ifndef MINHA_CLASSE_HPP // Se o símbolo MINHA_CLASSE_HPP não foi definido ainda...
#define MINHA_CLASSE_HPP // ...defina-o agora.

// Todo o conteúdo do header vai aqui
class MinhaClasse {
public:
    void fazer_algo();
};

#endif // Fim do bloco condicional
#+end_src

Na primeira vez que o header é incluído, MINHA_CLASSE_HPP não está definido, então o código é processado. Nas vezes subsequentes, o #ifndef falha, e o pré-processador pula todo o conteúdo, evitando a redefinição.

*Problemas do Modelo Clássico:*
  - Lentidão: O compilador precisa re-processar e re-analisar o conteúdo dos headers em cada arquivo .cpp que os inclui.

  - Vazamento de Abstração: Detalhes de implementação privados (variáveis membro privadas, funções de ajuda privadas) muitas vezes precisam ser declarados no arquivo de header, expondo a implementação interna.

  - Fragilidade: A ordem dos #include pode, às vezes, importar, e o uso excessivo do pré-processador pode levar a erros enigmáticos.

** 18.2 A Revolução do C++20: Módulos

Os módulos são a resposta do C++ moderno para todos os problemas do modelo clássico. Eles abandonam o pré-processador em favor de um sistema de importação semântico gerenciado pelo próprio compilador.

Um módulo é uma única unidade de compilação que exporta explicitamente os nomes (classes, funções, etc.) que deseja tornar públicos. Outras partes do código podem então importar o módulo para usar esses nomes.

*Exemplo Básico de Módulo:*
Vamos criar um módulo simples de matemática.

*1. Arquivo de Interface do Módulo (math.cppm):*
(A extensão .cppm ou .ixx é uma convenção comum para interfaces de módulo).
#+begin_src cpp
// math.cppm
export module math; // Declara este arquivo como a interface do módulo 'math'

// Uma função de ajuda interna. Não é exportada, portanto é invisível fora deste módulo.
long long internal_helper() {
    return 42;
}

// Exporta a função 'add'. Ela será parte da interface pública do módulo.
export int add(int a, int b) {
    return a + b;
}
#+end_src

*2. Arquivo Consumidor (main.cpp):*
#+begin_src cpp
// main.cpp
import math; // Importa a interface pública do módulo 'math'.
import <iostream>; // Módulos da biblioteca padrão também podem ser importados.

int main() {
    std::cout << "A soma é: " << add(5, 7) << std::endl;

    // A linha a seguir NÃO COMPILA, pois 'internal_helper' não foi exportada.
    // long long x = internal_helper(); // ERRO: 'internal_helper' não é visível.
}
#+end_src

*Benefícios dos Módulos:*
  - Compilação Rápida: O módulo é compilado uma única vez. Quando outros arquivos o importam, o compilador carrega uma representação pré-compilada, em vez de re-analisar o código-fonte.

  - Encapsulamento Forte: Apenas o que é explicitamente marcado com export é visível. Detalhes de implementação ficam verdadeiramente escondidos.

  -Sem Conflitos de Nomes: A importação de módulos não polui o escopo global como os #include fazem, eliminando problemas com macros e nomes conflitantes.

** 18.3 Compilando Módulos: Uma Nova Abordagem

Compilar código com módulos é um pouco diferente, pois o compilador precisa primeiro compilar a interface do módulo antes de compilar o código que a consome.

Usando GCC ou Clang, o processo geralmente se parece com isto:

#+begin_src bash
# 1. Compilar a interface do módulo 'math'.
# Isso cria math.o e um arquivo de metadados do módulo (ex: gcm.cache/math.gcm)
g++ -std=c++20 -fmodules-ts -c math.cppm -o math.o

# 2. Compilar o arquivo principal, que importa o módulo.
g++ -std=c++20 -fmodules-ts -c main.cpp -o main.o

# 3. Linkar os arquivos objeto para criar o executável final.
g++ -std=c++20 -fmodules-ts main.o math.o -o meu_programa
#+end_src

Como você pode ver, o processo de compilação se tornou mais complexo, com múltiplos passos e dependências claras. Fazer isso manualmente para cada mudança é impraticável. Isso nos leva diretamente à necessidade de uma ferramenta de automação, o que será o tópico do nosso próximo capítulo: Makefile.
