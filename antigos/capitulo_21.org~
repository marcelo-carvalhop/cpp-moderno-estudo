* Capítulo 21: A Filosofia da Estrutura de Diretórios — Um Blueprint para a Clareza

A transição de escrever scripts de um único arquivo para construir sistemas de software robustos começa com uma mudança de mentalidade. Devemos parar de ver nosso trabalho como uma coleção de arquivos de código-fonte e começar a vê-lo como um ecossistema de projeto. Este ecossistema inclui não apenas a implementação, mas também sua interface pública, seus testes, sua documentação, seus exemplos e a automação que une tudo. A estrutura de diretórios não é um contêiner passivo; é a primeira e mais visível manifestação da arquitetura do seu software. Ela comunica intenção, impõe disciplina e estabelece um caminho claro para a escalabilidade.

** 21.1 A Separação Fundamental: Interface (include) vs. Implementação (src)

No coração de qualquer projeto C++ bem estruturado reside a separação física entre o "quê" e o "como". Esta não é uma mera convenção, mas a aplicação do princípio do encapsulamento em nível de sistema de arquivos.

  - *src/ (Source): O Domínio da Implementação*
Este diretório contém os arquivos .cpp (e, como veremos, headers privados). É o motor do seu projeto, onde a lógica é definida, os algoritmos são implementados e os detalhes de baixo nível residem. A filosofia fundamental é que o conteúdo de src/ é um detalhe de implementação. Um consumidor da sua biblioteca nunca deve precisar navegar, ler ou, crucialmente, incluir arquivos diretamente deste diretório. O processo de build transforma o conteúdo de src/ em um produto final (uma biblioteca estática .a, uma biblioteca compartilhada .so, ou um executável), escondendo sua complexidade interna.

  - *include/ (Include): O Contrato Público*
Este diretório contém os arquivos de cabeçalho (.hpp) que formam a Interface de Programação de Aplicação (API) pública do seu projeto. Se uma classe, função ou tipo deve ser utilizável por um código externo, sua declaração pertence aqui. O conteúdo de include/ é um contrato. Ele representa uma promessa de estabilidade e funcionalidade para os usuários do seu projeto.

  - *O Padrão include/nome_do_projeto/ e o "Include Path"*
Uma prática de excelência é criar um subdiretório dentro de include/ com o nome do seu projeto.
*Estrutura:*
meu_projeto/
└── include/
    └── meu_projeto/
        ├── asset.hpp
        └── manager.hpp
Uso:
#+begin_src cpp
#include <meu_projeto/asset.hpp>
#+end_src

Por quê? Isso resolve o problema de colisão de nomes de headers. Imagine que seu projeto tem um utils.hpp. Se um consumidor do seu projeto também tiver um utils.hpp, o compilador pode encontrar o arquivo errado. Ao aninhar seus headers, você cria um espaço de nomes no sistema de arquivos. O consumidor pode incluir o seu com #include <meu_projeto/utils.hpp> e o dele com #include "utils.hpp", sem ambiguidade.
Como funciona? Você instrui o compilador a adicionar o diretório include/ (e não include/meu_projeto/) à sua lista de caminhos de busca. Com g++ ou clang, isso é feito com a flag -I:

#+begin_src bash
g++ -I/caminho/para/meu_projeto/include/ ...
#+end_src

Quando o compilador vê #include <meu_projeto/asset.hpp>, ele procura em seus caminhos de busca (incluindo o que foi adicionado por -I) por um diretório meu_projeto e, dentro dele, por asset.hpp.

- *Headers Privados (Internos)*
E se múltiplos arquivos .cpp dentro de src/ precisarem compartilhar uma função de ajuda ou uma declaração de classe que não faz parte da API pública? Colocá-la em include/ poluiria a interface pública. A solução é criar um header privado dentro de src/. A estrutura pode ser:
meu_projeto/
└── src/
    ├── internal/
    │   └── helpers.hpp
    ├── asset_loader.cpp   // #include "internal/helpers.hpp"
    └── texture_parser.cpp // #include "internal/helpers.hpp"
Como src/ não está no "include path" público, ninguém de fora pode acidentalmente incluir helpers.hpp.

** 21.2 O Santuário do Código-Fonte: Builds "Out-of-Source" (build)

O código-fonte é sagrado. Ele deve permanecer limpo, legível e livre de artefatos de compilação. A prática de compilar o projeto dentro de seu próprio diretório de código-fonte ("in-source build") é um antipadrão que leva ao caos. A solução profissional é o "out-of-source build".

  1. Crie um diretório build/: Este diretório viverá na raiz do seu projeto, ao lado de src/ e include/. Crucialmente, ele deve ser a primeira entrada no seu arquivo .gitignore.

  2. Execute o build a partir de dentro dele: O fluxo de trabalho é sempre:
#+begin_src bash

# A partir da raiz do projeto
mkdir -p build   # Cria o diretório se ele não existir
cd build

# Invoca o sistema de build (Makefile, CMake, etc.)
# Os caminhos para o código-fonte são relativos, ex: ../src/main.cpp
make 
# ou
cmake ..
#+end_src

Benefícios:

  - Limpeza Absoluta: Seu diretório de código-fonte permanece intocado. Para fazer uma reconstrução completa e limpa ("clean build"), não há necessidade de um make clean complexo. Basta executar rm -rf build/ e começar de novo. Isso elimina qualquer possibilidade de arquivos objeto antigos ou em cache causarem problemas.

  - Múltiplas Configurações: Este é o superpoder dos builds "out-of-source". Você pode manter múltiplas configurações de build independentes, usando a mesma base de código:
# Build de Debug, com símbolos de depuração
mkdir -p build-debug && cd build-debug && cmake -DCMAKE_BUILD_TYPE=Debug .. && make

# Build de Release, com otimizações máximas
mkdir -p build-release && cd build-release && cmake -DCMAKE_BUILD_TYPE=Release .. && make

# Build com AddressSanitizer para detectar erros de memória
mkdir -p build-asan && cd build-asan && cmake -DWITH_ASAN=ON .. && make
Cada diretório é um universo autocontido, sem interferir nos outros.

** 21.3 Garantia de Qualidade e Documentação Viva (tests e examples)
Um projeto sem testes é um projeto quebrado. Um projeto sem exemplos é um projeto inutilizável.

  - tests/: Este diretório contém o código que verifica a corretude do seu código em src/.
    - Estrutura: Idealmente, a estrutura de tests/ espelha a de src/. Se você tem src/core/asset.cpp, deveria ter tests/core/test_asset.cpp.
    - Frameworks: Escrever testes manualmente com assert() é primitivo. Um framework de testes (como Catch2 ou GoogleTest) fornece uma estrutura para organizar testes em casos, lidar com exceções, relatar falhas de forma detalhada e muito mais. O executável de teste é um cliente da sua biblioteca, assim como sua aplicação final. Ele linka com a biblioteca gerada a partir de src/ e a executa sob condições controladas.

  - examples/: Este diretório é ouro para os usuários.
    - Filosofia: Cada arquivo .cpp aqui deve ser um programa pequeno, completo e compilável que demonstra como usar uma parte específica da sua API. Eles são a sua documentação "viva", pois são compilados junto com o projeto, garantindo que nunca fiquem desatualizados em relação à API.

** 21.4 O Ecossistema do Projeto: Arquivos de Raiz e Metadados

A raiz do seu projeto é o seu cartão de visitas.

  - .gitignore: Essencial. Um bom .gitignore para C++ ignora o diretório build/, arquivos de backup de editores (como *~ do Emacs), arquivos de core dump e outros detritos.

  - README.md: O ponto de entrada. Deve explicar o que o projeto é, quais são suas dependências, como construí-lo (o exato fluxo mkdir build && cd build && ...) e como executá-lo.

  - LICENSE: O arquivo de licença (ex: MIT, GPL, Apache 2.0). Não versionar código sem uma licença é um erro legal que o torna proprietário por padrão e impede a colaboração.

  - CONTRIBUTING.md: Se o projeto for de código aberto, este arquivo explica as regras para contribuições: estilo de código, como submeter pull requests, etc.

  - docs/: Para documentação mais longa e formal. Pode conter arquivos Markdown ou ser o destino para a saída de ferramentas de geração de documentação como o Doxygen, que extrai comentários formatados do seu código-fonte para criar uma referência completa da API.

  - scripts/: Um lugar para scripts de ajuda: um format.sh que executa clang-format em todo o código, um run_tests.sh que constrói e executa os testes, etc.

Ao adotar esta estrutura, você não está apenas organizando arquivos. Você está construindo uma máquina de desenvolvimento, onde cada parte tem um propósito claro, facilitando a manutenção, a colaboração e o crescimento sustentável do seu software.

|[[./capitulo_20.org][Anterior]]|[[./cpp_moderno_indice.org][Índice]]|[[./capitulo_21.org][Próximo]]|
