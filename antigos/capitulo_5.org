* Capítulo 5: Funções — A Arte de Organizar a Lógica

Até agora, todo o nosso código residiu dentro de um único bloco: a função main(). Para programas pequenos, isso é suficiente. Mas imagine tentar construir um sistema complexo — um motor de jogo, um navegador web, um sistema de análise de dados — dentro de um único e gigantesco bloco de código. Seria um pesadelo de gerenciar, depurar e entender.

As funções são a solução para este caos. Elas são a ferramenta mais fundamental da programação para criar abstração e organização. Uma função é um bloco de código nomeado, autocontido, que realiza uma tarefa específica. Pense nelas como os cômodos de uma casa: em vez de ter uma única sala gigante para cozinhar, dormir e trabalhar, você tem uma cozinha, um quarto e um escritório, cada um com um propósito claro.

Neste capítulo, aprenderemos a criar e usar essas "salas" lógicas, transformando nosso código de uma lista de instruções para uma coleção de comportamentos bem definidos.

** 5.1 A Anatomia de uma Função

Uma função em C++ tem quatro componentes principais:

  1. Tipo de Retorno: O tipo de dado que a função "devolve" após sua execução. Se a função não devolve nada, usamos o tipo especial void.

  2. Nome da Função: Um identificador que usamos para chamar a função.

  3. Lista de Parâmetros (ou Argumentos): As informações que passamos para dentro da função para que ela possa trabalhar. Fica entre parênteses ().

  4. Corpo da Função: O bloco de código, entre chaves {}, que contém as instruções que a função executa.

#+begin_src cpp
//  (1)      (2)        (3)
tipo_de_retorno nome(lista_de_parâmetros) {
    // (4) Corpo da função...
    // ...lógica...
    return valor; // Opcional, dependendo do tipo de retorno
}
#+end_src

Vamos criar uma função simples que soma dois inteiros:

#+begin_src cpp

#include <iostream>

// Definição da nossa função 'somar'
int somar(int a, int b) {
    int resultado = a + b;
    return resultado; // Devolve o resultado da soma
}

int main() {
    int x = 10;
    int y = 20;

    // Chamando a função e armazenando o valor retornado
    int total = somar(x, y);

    std::cout << "A soma de " << x << " e " << y << " é " << total << std::endl; // Saída: 30
    return 0;
}
#+end_src

** 5.2 Declaração vs. Definição: A Promessa e a Execução

No exemplo acima, a definição da função somar veio antes de main(). Mas e se quiséssemos definir main() primeiro?

#+begin_src cpp
// Isso causaria um erro de compilação!
// O compilador em main() não sabe o que 'somar' é.
#+end_src

Para resolver isso, separamos a declaração da definição.

  - Declaração (ou protótipo): É uma promessa ao compilador. Ela diz: "Existe uma função com este nome, que aceita estes parâmetros e retorna este tipo. A implementação (o corpo) está em outro lugar".
  - Definição: É a implementação real, o corpo da função.

#+begin_src cpp
#include <iostream>

// 1. Declaração da função (a promessa)
int somar(int a, int b);

int main() {
    int total = somar(10, 20); // Funciona! O compilador confia na promessa.
    std::cout << "O total é: " << total << std::endl;
    return 0;
}

// 2. Definição da função (cumprindo a promessa)
int somar(int a, int b) {
    return a + b;
}
#+end_src

Este conceito é a base de como projetos C++ são organizados em múltiplos arquivos, usando arquivos de cabeçalho (.h ou .hpp) para as declarações e arquivos de código (.cpp) para as definições.

** 5.3 Passando Dados para Funções: A Mecânica da Comunicação

Como a informação flui para dentro de uma função é um dos aspectos mais importantes e sutis do C++.

*** 5.3.1 Passagem por Valor (Pass-by-Value)

Este é o comportamento padrão. Quando você passa uma variável por valor, a função recebe uma cópia do dado original.

#+begin_src cpp
void tentarModificar(int numero) {
    numero = 100; // Modifica a CÓPIA local
    std::cout << "Dentro da função, numero é: " << numero << std::endl; // Saída: 100
}

int main() {
    int valorOriginal = 5;
    tentarModificar(valorOriginal);
    std::cout << "Fora da função, valorOriginal é: " << valorOriginal << std::endl; // Saída: 5
}
#+end_src

  - Vantagem: É seguro. A função não pode modificar acidentalmente a variável original.

  - Desvantagem: Copiar pode ser caro! Imagine passar um objeto que ocupa megabytes de memória. Fazer uma cópia completa a cada chamada de função seria um desastre de performance.

*** 5.3.2 Passagem por Referência (Pass-by-Reference)

Para evitar cópias e/ou permitir que a função modifique o dado original, usamos a passagem por referência, indicada por um & no tipo do parâmetro. Uma referência é um apelido (alias) para a variável original. Não há cópia.

#+begin_src cpp
void modificarDeVerdade(int& numero) { // Note o '&'
    numero = 100; // Modifica o DADO ORIGINAL
}

int main() {
    int valorOriginal = 5;
    modificarDeVerdade(valorOriginal);
    std::cout << "Agora, valorOriginal é: " << valorOriginal << std::endl; // Saída: 100
}
#+end_src

*** 5.3.3 A Melhor Prática: Referência para const

E se quisermos a eficiência da referência (sem cópia), mas a segurança do valor (sem modificação)? A solução é a referência para constante (const&).

#+begin_src cpp
// std::string pode ser um objeto grande
void imprimirNome(const std::string& nome) { // const &
    // nome = "Outro"; // ERRO DE COMPILAÇÃO! Não podemos modificar uma referência const.
    std::cout << "O nome é: " << nome << std::endl;
}
#+end_src

Regra de Ouro do C++ Moderno:

  - Para tipos primitivos e pequenos (int, double, char), passe por valor.
  - Para objetos grandes (std::string, std::vector, classes), passe por referência para const (const&) se a função só precisa ler o dado.
  - Passe por referência (&) apenas se a função precisa modificar o dado original.

** 5.4 Tópicos Avançados de Funções

*** 5.4.1 Sobrecarga de Funções (Function Overloading)

C++ permite que você defina múltiplas funções com o mesmo nome, desde que suas listas de parâmetros sejam diferentes (seja no número ou no tipo dos parâmetros). O compilador escolhe a versão correta com base nos argumentos que você passa.

#+begin_src cpp
void imprimir(int i) { std::cout << "Imprimindo um int: " << i << std::endl; }
void imprimir(double d) { std::cout << "Imprimindo um double: " << d << std::endl; }
void imprimir(const std::string& s) { std::cout << "Imprimindo uma string: " << s << std::endl; }

imprimir(10);       // Chama a versão (int)
imprimir(3.14);     // Chama a versão (double)
imprimir("Olá");    // Chama a versão (const std::string&)
#+end_src

*** 5.4.2 Argumentos Padrão

Você pode fornecer um valor padrão para um ou mais parâmetros. Se o chamador não fornecer um argumento para esse parâmetro, o valor padrão será usado.

#+begin_src cpp
void criarAlerta(const std::string& mensagem, bool erroGrave = false) {
    if (erroGrave) {
        std::cout << "!!! ERRO GRAVE: " << mensagem << " !!!" << std::endl;
    } else {
        std::cout << "Aviso: " << mensagem << std::endl;
    }
}

criarAlerta("Conexão perdida");             // erroGrave será false
criarAlerta("Memória insuficiente", true);  // erroGrave será true
#+end_src

*** 5.4.3 O Especificador noexcept

Em C++ Moderno, podemos (e devemos) informar ao compilador se uma função garante não lançar exceções. Isso é feito com o especificador noexcept.

#+begin_src cpp
// Esta função promete não lançar exceções
int somar(int a, int b) noexcept {
    return a + b;
}
#+end_src

Por que isso é importante? Se o compilador sabe que uma função é noexcept, ele pode gerar um código significativamente mais otimizado e rápido, pois não precisa se preocupar com a complexa mecânica de tratamento de exceções.

** 5.5 Resumo do Capítulo: Construindo com Blocos

As funções são o pilar da programação estruturada. Elas nos permitem:

  - Organizar nosso código em unidades lógicas e nomeadas.
  - Reutilizar lógica sem copiar e colar código (princípio DRY - Don't Repeat Yourself).
  - Abstrair detalhes de implementação, permitindo-nos pensar em um nível mais alto.

Aprendemos a diferença crucial entre passagem por valor (cópia segura) e passagem por referência (alias eficiente), e estabelecemos que const& é a nossa ferramenta padrão para passar objetos grandes.

Nós construímos os cômodos da nossa casa. Eles são funcionais e organizados. Mas logo perceberemos que precisamos de um "encanamento" mais sofisticado para conectar esses cômodos e manipular os dados que fluem entre eles de maneiras ainda mais poderosas e flexíveis. Essa necessidade nos levará diretamente ao nosso próximo tópico, o coração do controle de baixo nível em C++: ponteiros e a realidade da memória.


|[[./capitulo_4.org][Anterior]]|[[./cpp_moderno_indice.org][Índice]]|[[./capitulo_6.org][Próximo]]|
