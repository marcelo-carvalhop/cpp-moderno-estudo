* O Conceito de Lvalue no C++

Ao estudar o C++ moderno, é comum ouvir falar em /lvalues/ e /rvalues/. O programador iniciante normalmente entende que lvalue é “algo que pode aparecer à esquerda de uma atribuição”, mas essa definição, embora útil historicamente, é limitada. O C++ evoluiu, e a terminologia também. Um lvalue não é apenas “algo atribuível”: é um valor que possui identidade, persistência e um endereço de memória acessível.

Neste capítulo vamos dissecar o que é um /lvalue/, como ele se diferencia de um /rvalue/, quais as implicações práticas no design de código e como explorá-lo em funções, referências e sobrecargas.

** O que é um lvalue?

Formalmente, um /lvalue/ é uma expressão que se refere a um objeto localizado em um endereço de memória identificável. Em termos mais simples: é algo que “tem nome” e cuja existência se prolonga além da expressão atual.

Exemplo básico:
#+begin_src cpp
#include <iostream>

int main() {
    int x = 42;   // 'x' é um lvalue: tem nome, ocupa um lugar na memória
    int y = x;    // 'x' é usado aqui como lvalue, fornecendo seu conteúdo

    std::cout << &x << " -> " << x << std::endl;
}
#+end_src

Neste caso, 'x' é claramente um lvalue: podemos tirar seu endereço ('&x'), podemos modificar seu conteúdo ('x = 100;'), e ele existe até o final do bloco.

** 2. Lvalues e identidade

Um rvalue não tem identidade: é apenas um valor passageiro. Já um lvalue tem uma vida mais longa e pode ser reutilizado.

#+begin_src cpp
int main() {
    int a = 10;    // 'a' é lvalue
    int b = 20;    // 'b' é lvalue

    a = b;         // aqui, 'a' é lvalue no lado esquerdo, 'b' é lvalue no lado direito
}
#+end_src 

Apesar de estar no lado direito, 'b' continua sendo um lvalue: podemos obter '&b', ele tem nome e dura até o final do escopo. O critério não é a posição na atribuição, mas sim a identidade persistente.

** Referências a lvalues (T&)

O C++ fornece uma maneira explícita de trabalhar com lvalues: as referências comuns ('T&'). Uma função que recebe um parâmetro como 'int&' exige um lvalue: não podemos passar um temporário para ela.

#+begin_src cpp
#include <iostream>

void recebe_lvalue(int& x) {
    x += 10;
    std::cout << "Valor modificado: " << x << std::endl;
}

int main() {
    int n = 5;
    recebe_lvalue(n);   // OK: n é um lvalue

    // recebe_lvalue(5); // ERRO: 5 é um rvalue, não pode se ligar a int&
}
#+end_src 

Esse mecanismo garante segurança: a função sabe que está operando sobre um objeto que existe fora dela e continuará existindo após sua execução.

** Const lvalue references ('const T&')

Existe, porém, um detalhe poderoso: uma referência a lvalue constante ('const T&') pode se ligar tanto a lvalues quanto a rvalues. Isso permite que funções aceitem temporários sem perda de eficiência, já que não precisam copiar o objeto.

#+begin_src cpp
#include <iostream>
#include <string>

void imprime(const std::string& s) {
    std::cout << s << std::endl;
}

int main() {
    std::string nome = "Marcelo";
    imprime(nome);             // lvalue
    imprime("Horizonte");      // rvalue, mas aceito por const std::string&
}
#+end_src

Nesse exemplo, "Horizonte" é um rvalue, mas imprime pode recebê-lo porque a referência é constante e garante que não haverá modificações perigosas.

** Atribuição e lvalues

Por definição, apenas /lvalues/ podem aparecer à esquerda de uma atribuição. É essa característica que deu origem ao nome “locator value”.

#+begin_src cpp
int main() {
    int x = 1;
    int y = 2;

    x = y;     // OK: x é lvalue
    // (x + y) = 3; // ERRO: (x + y) é um rvalue
}
#+end_src

Isso reforça a ideia de que lvalues têm “lugar” na memória, enquanto rvalues não têm.

** Exemplo prático: função que modifica lvalues

Vamos criar uma função que só aceita lvalues porque precisa modificá-los.

#+begin_src cpp
#include <iostream>

void dobrar(int& valor) {
    valor *= 2;
}

int main() {
    int a = 10;
    dobrar(a);    // funciona: a é um lvalue
    std::cout << "a = " << a << std::endl;

    // dobrar(10); // erro: 10 é rvalue
}
#+end_src

Saída:

#+begin_src bash
a = 20
#+end_src

Isso deixa claro que referências a lvalues ('int&') são usadas quando precisamos garantir que a função trabalhe sobre um objeto real e persistente.

** Lvalues em sobrecargas

Uma das grandes vantagens de entender a diferença entre lvalues e rvalues é a possibilidade de criar sobrecargas específicas.

#+begin_src cpp
#include <iostream>
#include <string>

void processa(std::string& s) {
    std::cout << "Processando lvalue: " << s << std::endl;
}

void processa(std::string&& s) {
    std::cout << "Processando rvalue: " << s << std::endl;
}

int main() {
    std::string nome = "Marcelo";
    processa(nome);            // chama versão lvalue
    processa("Horizonte");     // chama versão rvalue
}
#+end_src

Aqui, o compilador escolhe automaticamente a versão correta da função com base no tipo de expressão passada.

** Conclusão

Um lvalue é mais do que apenas “algo que pode aparecer à esquerda de uma atribuição”. Ele representa um objeto com identidade, endereço e vida útil além da expressão atual. Essa característica é essencial no C++ porque permite manipular objetos de forma eficiente e previsível, ao mesmo tempo que se combina com as referências rvalue (T&&) para habilitar a semântica de movimento.

Em resumo: enquanto rvalues são passageiros, lvalues são cidadãos permanentes da memória. Dominar essa diferença é fundamental para escrever código moderno, eficiente e expressivo em C++.
