* Notas de Aprofundamento: Exceções e Códigos de Retorno

Quando se fala em tratamento de erros em C++, há uma camada adicional de complexidade que não aparece imediatamente em um contraste superficial entre exceções e códigos de erro. A primeira dimensão importante é a daquilo que a comunidade chama de /exception safety guarantees/. Essas garantias são classificações formais do que o código promete em presença de exceções. Existe a garantia básica, que assegura apenas que invariantes fundamentais do programa não serão corrompidos, ainda que o estado da operação não seja preservado. A seguir, temos a garantia forte, que promete transações: ou a operação completa com sucesso, ou o programa retorna ao estado anterior, como se nada tivesse acontecido. No nível máximo, temos a garantia de não-lançamento (/no-throw/), na qual a função é explicitamente marcada como incapaz de lançar exceções, seja por construção ou pelo uso do especificador 'noexcept'. Essas distinções são mais do que nomenclaturas: influenciam profundamente o design de bibliotecas, já que permitem ao desenvolvedor e ao usuário saberem que riscos correm em operações críticas.

Outro ponto pouco explorado em discussões superficiais é o impacto de exceções na geração de código e na performance em arquiteturas reais. O modelo conhecido como /zero-cost exception handling/ tenta assegurar que, enquanto nenhuma exceção é lançada, o caminho normal de execução não incorre em penalidade significativa. Contudo, essa promessa não é totalmente gratuita: o compilador precisa manter tabelas ocultas, dados extras e instruções auxiliares para permitir o /stack unwinding/ posterior. Essa preparação pode afetar tanto o tamanho do binário quanto o comportamento de otimizações do compilador, e em sistemas de tempo real, a incerteza sobre o custo do lançamento efetivo de uma exceção é considerada inaceitável. Por isso, ambientes como jogos de alto desempenho (Unreal Engine, por exemplo) e sistemas embarcados frequentemente optam por desativar exceções no compilador, adotando um estilo puramente baseado em códigos de erro ou tipos de retorno.

Ao olhar para linguagens vizinhas, é possível ver diferentes soluções para o mesmo dilema. Em Java e C#, por exemplo, exceções são o mecanismo padrão e praticamente inevitável, já que códigos de erro são considerados práticas legadas. Em Go, por outro lado, o modelo é radicalmente explícito: cada função retorna sempre um valor e um erro, e o chamador deve tratar imediatamente. Rust introduz talvez a síntese mais próxima ao que C++ está buscando hoje: com o tipo 'Result<T, E>', inspirado em Haskell, falhas operacionais são valores comuns, mas o compilador força o desenvolvedor a lidar com eles. Em paralelo, 'panic!' é reservado para falhas realmente excepcionais, ecoando a mesma separação que C++ tenta estabelecer entre expected failures e logic errors.

Também é útil observar que a própria STL e as diretrizes modernas (como o C++ Core Guidelines de Herb Sutter e Bjarne Stroustrup) defendem uma linha híbrida: exceções devem ser reservadas a situações de violação de contrato, invariantes quebrados ou falhas profundas, enquanto falhas esperadas — como abrir um arquivo que não existe — devem ser modeladas com retornos explícitos, sejam 'optional', 'expected' ou variantes mais elaboradas. Essa postura é reflexo de um amadurecimento da linguagem: não se trata mais de escolher um campo filosófico, mas de reconhecer que diferentes classes de falhas exigem mecanismos distintos.

Por fim, há a questão cultural. Programadores vindos de C e de contextos de sistemas embarcados frequentemente desconfiam de exceções, associando-as a custo e imprevisibilidade. Já desenvolvedores acostumados a linguagens de alto nível tendem a vê-las como a maneira mais natural e limpa de lidar com erros. Esse choque cultural se reflete até em grandes empresas e projetos: o Google, por exemplo, recomenda evitar exceções em suas bibliotecas C++, enquanto a Microsoft e a própria STL baseiam parte significativa de suas interfaces nelas. O resultado é que qualquer programador de C++ contemporâneo precisa dominar ambas as técnicas, entendendo suas forças, suas fraquezas e, principalmente, os contextos em que cada uma deve ser aplicada.
