* Cap√≠tulo 13: Exce√ß√µes vs. C√≥digo Robusto Sem Exce√ß√µes

** Contexto Hist√≥rico e Filos√≥fico

C++ herdou da sua heran√ßa dupla (C e Simula) duas vis√µes de tratamento de erros. Do lado de C, veio a cultura dos c√≥digos de erro e errno, pr√°tica direta, mas sujeita a erros de verifica√ß√£o. Do lado de linguagens orientadas a objetos, veio a filosofia de exce√ß√µes como mecanismo de separa√ß√£o sem√¢ntica entre fluxo normal e fluxo an√¥malo.

Esse choque de culturas permanece vivo at√© hoje:

  - A escola das exce√ß√µes v√™ erros como algo qualitativamente diferente do fluxo normal, merecendo um mecanismo especial.
  - A escola dos retornos v√™ erros como dados normais que devem ser tratados localmente, com o compilador ajudando a for√ßar o manuseio.

13.1 O Modelo das Exce√ß√µes
Filosofia

Exce√ß√µes s√£o usadas quando o contrato fundamental de uma fun√ß√£o n√£o pode ser cumprido. S√£o, portanto, um mecanismo para falhas inesperadas, e n√£o para resultados alternativos triviais.

Pontos de For√ßa

C√≥digo limpo e expressivo: O ‚Äúcaminho feliz‚Äù fica livre de verifica√ß√µes de erro repetitivas.

Stack unwinding autom√°tico: garante que destrutores de RAII sejam chamados ‚Äî uma das maiores vantagens em sistemas complexos.

Transporte de contexto: exce√ß√µes podem carregar mensagens, c√≥digos, ou objetos inteiros descrevendo a falha.

M√≥dulos independentes: um m√≥dulo pode lan√ßar exce√ß√µes sem que os chamadores precisem conhecer todos os c√≥digos poss√≠veis.

Cr√≠ticas e Dificuldades

Custo em tempo de execu√ß√£o: lan√ßar exce√ß√µes envolve estruturas internas, tabelas de stack unwinding e busca de handlers.

Fluxo de controle impl√≠cito: pode ser dif√≠cil rastrear onde exatamente um erro ser√° capturado.

Compatibilidade: em ambientes restritos (embedded, games, drivers) exce√ß√µes frequentemente s√£o desativadas.

Complexidade de biblioteca: templates gen√©ricos e exce√ß√µes podem interagir de forma explosiva (padr√µes como noexcept ajudam a controlar isso).

Exemplo Pr√°tico
#include <iostream>
#include <stdexcept>
#include <vector>

int acesso_seguro(const std::vector<int>& v, size_t i) {
    if (i >= v.size())
        throw std::out_of_range("√çndice inv√°lido: " + std::to_string(i));
    return v[i];
}

int main() {
    try {
        std::vector<int> dados = {1, 2, 3};
        std::cout << acesso_seguro(dados, 5) << "\n";
    } catch (const std::exception& e) {
        std::cerr << "Erro capturado: " << e.what() << "\n";
    }
}

13.2 O Modelo Sem Exce√ß√µes
Filosofia

Aqui, falhas n√£o s√£o excepcionais: s√£o resultados esperados. O erro √© tratado como parte do contrato da fun√ß√£o.

Estrat√©gias

C√≥digos de retorno: simples, mas fr√°geis (o chamador pode ignorar).

Par√¢metros de sa√≠da + bool: reduz risco, mas √© verboso.

Tipos modernos (optional/expected): representam explicitamente a possibilidade de falha, com suporte do compilador.

Pontos de For√ßa

Expl√≠cito e local: chamador sempre lida com o resultado.

Performance previs√≠vel: sem stack unwinding, mais adequado para sistemas embarcados e tempo real.

Universalidade: funciona mesmo em compiladores/configura√ß√µes sem exce√ß√µes.

Cr√≠ticas

Verboso: muitas verifica√ß√µes if podem poluir c√≥digo.

Risco de descuido: programadores podem ignorar retornos (embora [[nodiscard]] em C++17 ajude).

Composi√ß√£o complexa: encadear v√°rias fun√ß√µes com optional/expected pode levar a aninhamentos profundos.

Exemplo com std::expected
#include <iostream>
#include <expected>
#include <string>

enum class Erro { Invalido, ForaDoRange };

std::expected<int, Erro> string_para_int(const std::string& s) {
    try {
        return std::stoi(s);
    } catch (const std::invalid_argument&) {
        return std::unexpected(Erro::Invalido);
    } catch (const std::out_of_range&) {
        return std::unexpected(Erro::ForaDoRange);
    }
}

int main() {
    auto r = string_para_int("abc");
    if (r) {
        std::cout << "Valor: " << *r << "\n";
    } else {
        std::cout << "Erro de convers√£o\n";
    }
}

13.3 A Vis√£o Moderna: Escolha Contextual
Quando preferir exce√ß√µes

Viola√ß√£o de invariantes, erros graves que n√£o fazem parte do ‚Äúfluxo normal‚Äù.

Bibliotecas gen√©ricas onde os chamadores podem reagir de formas variadas.

Situa√ß√µes em que a clareza e a robustez de RAII superam o custo de performance.

Quando preferir retornos

Resultados esperados (ex.: ‚Äúarquivo n√£o existe‚Äù, ‚Äúusu√°rio digitou errado‚Äù).

APIs p√∫blicas onde for√ßar tratamento expl√≠cito √© desej√°vel.

Ambientes sem suporte a exce√ß√µes.

C√≥digo de performance cr√≠tica em hot paths.

13.4 T√©cnicas Avan√ßadas

noexcept: especifica que uma fun√ß√£o n√£o lan√ßa exce√ß√µes, ajudando o compilador a otimizar.

Exce√ß√µes e templates: deve-se projetar interfaces gen√©ricas para n√£o dependerem fortemente de pol√≠ticas de exce√ß√µes.

Erro como parte do tipo: std::variant ou tipos mon√°dicos (em bibliotecas funcionais de C++) permitem encadear computa√ß√µes que podem falhar de forma elegante.

Programa√ß√£o defensiva: combinar verifica√ß√µes est√°ticas (static_assert, contratos C++20) com runtime.

13.5 Boas Pr√°ticas Recomendadas

Sempre documentar se uma fun√ß√£o pode lan√ßar ou n√£o (noexcept quando aplic√°vel).

Usar [[nodiscard]] para fun√ß√µes que retornam optional/expected.

Lan√ßar exce√ß√µes apenas em situa√ß√µes realmente excepcionais.

N√£o misturar arbitrariamente exce√ß√µes e c√≥digos de erro na mesma API.

Seguir guidelines de grandes projetos (Core Guidelines: [E.12, E.14, E.15]).

üëâ Em resumo:

Exce√ß√µes ‚Üí Para erros inesperados e cr√≠ticos, que quebram o contrato.

Retornos (optional/expected) ‚Üí Para erros esperados e operacionais, que fazem parte do dom√≠nio.

Essa s√≠ntese n√£o √© apenas teoria ‚Äî ela guia o design das bibliotecas padr√£o modernas (C++17/20/23) e de gigantes como Google, LLVM e Microsoft.
