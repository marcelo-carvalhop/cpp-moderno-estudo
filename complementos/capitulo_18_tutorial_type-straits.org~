Tutorial prático e completo de C++ <type_traits> para humanos

Este é um guia narrativo e prático sobre a biblioteca <type_traits> do C++. A ideia é ensinar com linguagem simples, indo do básico ao avançado, e sempre com exemplos que você consegue compilar e executar. Evitarei ao máximo ficar em “listas” e termos acadêmicos; em vez disso, vou contar o que cada coisa faz, por que existe, e como usar no dia a dia para resolver problemas reais.

Observação sobre tamanho: um tutorial com “pelo menos 2000 linhas” não cabe em uma mensagem única aqui. Então deixo abaixo uma versão muito completa e prática, mas mais compacta que 2000 linhas. Se você quiser a versão realmente gigantesca com 2000+ linhas, posso gerar um DOCX ou PDF com o conteúdo completo e exemplos extras. É só dizer que prefere em DOCX ou PDF, que eu entrego.

O que é <type_traits> e por que usar

Quando você escreve templates em C++, muitas vezes precisa tomar decisões “em tempo de compilação” dependendo do tipo T que o usuário do seu template passou. Por exemplo: se T é um número inteiro, faça uma coisa; se é um ponteiro, faça outra; se é uma classe que tem um método específico, ative uma função; se não tiver, esconda aquela função. Para isso, o C++ oferece uma enorme coleção de “características de tipo” — os type traits — que respondem perguntas sobre tipos (é integral? é enum? é const? é conversível para X?) e também transformam tipos (remove const, adiciona referência, pega o tipo base de um enum, etc.).

Essa biblioteca permite:

Inspecionar tipos: descobrir “o que T é”.
Combinar regras: “T é integral E sem sinal?”.
Transformar tipos: tirar const, referência, ponteiro, etc.
Ativar/desativar sobrecargas: habilitar funções só quando a condição sobre o tipo é verdadeira (SFINAE).
Inferir resultados: descobrir o tipo de retorno de uma chamada (invoke_result), ou se algo é invocável.

É como ter “if/else” em tempo de compilação para seus tipos.

Convenções úteis que você verá nos exemplos

Quase todos os traits existem em três sabores:

A versão “tipo clássico” que tem um membro estático value (por exemplo, std::is_integral::value).
A versão “_v” que dá o valor direto (std::is_integral_v), muito mais prática.
Em traits que produzem um tipo, existe o atalho “_t” (por exemplo, std::remove_cv_t).

Vou usar C++17/C++20 onde fizer sentido. Se você estiver em C++14, dá para adaptar. Sempre inclua:

#include <type_traits>


E, para exemplos que imprimem, você vai ver:

#include <iostream>
#include <string>
#include <vector>
#include <utility>   // às vezes necessário para std::declval, std::swap


Quando eu mostrar “arquivos”, considere que cada exemplo é um arquivo separado com sua função main. Assim você pode compilar um por vez sem conflitos.

1) O alicerce: integral_constant, true_type e false_type

A base filosófica de <type_traits> é que muitas respostas são “constantes em tempo de compilação” ligadas a tipos. A classe std::integral_constant representa um número inteiro como um tipo. A partir dela surgem std::true_type e std::false_type (que são só integral_constant<bool, true/false>).

Para nós, o mais útil na prática é: a maioria dos traits já fornece um booleano em tempo de compilação. Isto é perfeito para static_assert, if constexpr, SFINAE, etc.

Exemplo 1 — um olá mundo de traits para imprimir se um tipo é integral:

// arquivo: exemplo1.cpp
#include <type_traits>
#include <iostream>
using namespace std;

template <typename T>
void descreve_tipo() {
    if constexpr (std::is_integral_v<T>) {
        cout << "T é um tipo integral.\n";
    } else if constexpr (std::is_floating_point_v<T>) {
        cout << "T é um ponto flutuante.\n";
    } else if constexpr (std::is_enum_v<T>) {
        cout << "T é um enum.\n";
    } else if constexpr (std::is_class_v<T>) {
        cout << "T é uma classe/struct.\n";
    } else {
        cout << "T é de outra categoria.\n";
    }
}

enum Cor { Vermelho, Verde, Azul };
struct Pessoa {};

int main() {
    descreve_tipo<int>();
    descreve_tipo<double>();
    descreve_tipo<Cor>();
    descreve_tipo<Pessoa>();
    descreve_tipo<int*>();
}


Esse padrão if constexpr é fundamental para “ramificar” sua lógica de forma limpa sem truques obscuros.

2) Perguntas básicas sobre um tipo

Você pode fazer um check-up completo de um tipo com traits como:

std::is_void, std::is_null_pointer
std::is_integral, std::is_floating_point, std::is_arithmetic (integrais OU ponto flutuante)
std::is_enum, std::is_union, std::is_class, std::is_function
std::is_pointer, std::is_reference, std::is_lvalue_reference, std::is_rvalue_reference
std::is_array

Esses traits respondem com bool em tempo de compilação.

Exemplo 2 — explorador simples:

// arquivo: exemplo2.cpp
#include <type_traits>
#include <iostream>
#include <string>
using namespace std;

template <typename T>
void explora() {
    cout << boolalpha;
    cout << "is_void: " << std::is_void_v<T> << "\n";
    cout << "is_null_pointer: " << std::is_null_pointer_v<T> << "\n";
    cout << "is_integral: " << std::is_integral_v<T> << "\n";
    cout << "is_floating_point: " << std::is_floating_point_v<T> << "\n";
    cout << "is_arithmetic: " << std::is_arithmetic_v<T> << "\n";
    cout << "is_enum: " << std::is_enum_v<T> << "\n";
    cout << "is_class: " << std::is_class_v<T> << "\n";
    cout << "is_pointer: " << std::is_pointer_v<T> << "\n";
    cout << "is_reference: " << std::is_reference_v<T> << "\n";
    cout << "is_array: " << std::is_array_v<T> << "\n";
    cout << "\n";
}

enum E {};
struct S {};

int main() {
    explora<int>();
    explora<double>();
    explora<E>();
    explora<S>();
    explora<int*>();
    explora<const int&>();
    explora<void>();
    explora<nullptr_t>();
    explora<int[3]>();
    explora<string>();
}

3) Qualificadores (const/volatile) e referências

Quando você escreve templates, é comum “normalizar” um tipo: tirar const, tirar referência, tirar volatile, ou o combo “cvref” ao mesmo tempo. Os traits de transformação mais usados são:

std::remove_const_t, std::remove_volatile_t, std::remove_cv_t
std::remove_reference_t, std::remove_cvref_t (C++20)
std::add_const_t, std::add_volatile_t, std::add_cv_t
std::add_lvalue_reference_t, std::add_rvalue_reference_t

Exemplo 3 — normalizando tipos:

// arquivo: exemplo3.cpp
#include <type_traits>
#include <iostream>
using namespace std;

template <typename T>
void mostra_normalizacoes() {
    using SemRef = std::remove_reference_t<T>;
    using SemCV = std::remove_cv_t<T>;
    using SemCVRef = 
    #if __cplusplus >= 202002L
        std::remove_cvref_t<T>;
    #else
        std::remove_cv_t<std::remove_reference_t<T>>;
    #endif

    cout << boolalpha;
    cout << "is_const<T>: " << std::is_const_v<T> << "\n";
    cout << "is_volatile<T>: " << std::is_volatile_v<T> << "\n";
    cout << "is_reference<T>: " << std::is_reference_v<T> << "\n";
    cout << "is_same<SemRef,SemCVRef>: " << std::is_same_v<SemRef, SemCVRef> << "\n";
    cout << "\n";
}

int main() {
    mostra_normalizacoes<const int&>();
    mostra_normalizacoes<volatile int&&>();
    mostra_normalizacoes<int>();
}


Uma dica valiosa: quando você quer tratar “o tipo nu” ignorando const, volatile e referências, use remove_cvref_t (C++20) ou o equivalente manual.

4) Arrays, ponteiros e detalhes como rank/extent

Para arrays, temos:

std::is_array_v
std::rank_v dá quantas dimensões o array tem (rank).
std::extent_v<T, N> dá o tamanho da dimensão N (0 é a primeira).
std::remove_extent_t remove uma dimensão.
std::remove_all_extents_t remove todas.

Para ponteiros:

std::is_pointer_v, std::remove_pointer_t, std::add_pointer_t.

Exemplo 4 — investigando um array multidimensional:

// arquivo: exemplo4.cpp
#include <type_traits>
#include <iostream>
using namespace std;

template <typename T>
void info_array() {
    cout << boolalpha;
    cout << "is_array: " << std::is_array_v<T> << "\n";
    cout << "rank: " << std::rank_v<T> << "\n";
    if constexpr (std::rank_v<T> >= 1) {
        cout << "extent<0>: " << std::extent_v<T, 0> << "\n";
    }
    if constexpr (std::rank_v<T> >= 2) {
        cout << "extent<1>: " << std::extent_v<T, 1> << "\n";
    }
    cout << "\n";
}

int main() {
    info_array<int[3]>();
    info_array<int[2][4]>();
    info_array<int>();
}

5) Relações entre tipos: is_same, is_base_of, is_convertible, is_assignable, is_constructible

Muitas decisões úteis dependem de relações:

std::is_same_v<A,B> verifica igualdade exata de tipos.
std::is_base_of_v<Base, Derivada> testa herança.
std::is_convertible_v<From, To> testa se uma conversão existe.
std::is_assignable_v<To&, From> testa se To pode receber From via “operator=”.
std::is_constructible_v<T, Args...> testa se T pode ser construído com Args.

Exemplo 5 — habilitar função só para quem é conversível para double:

// arquivo: exemplo5.cpp
#include <type_traits>
#include <iostream>
#include <string>
using namespace std;

template <typename T>
std::enable_if_t<std::is_convertible_v<T, double>, double>
para_double(T&& x) {
    return static_cast<double>(x);
}

template <typename T>
std::enable_if_t<!std::is_convertible_v<T, double>, double>
para_double(T&&) {
    // fallback
    return 0.0;
}

int main() {
    cout << para_double(42) << "\n";          // 42.0
    cout << para_double(3.14f) << "\n";       // 3.14
    cout << para_double(string("abc")) << "\n"; // não é conversível -> 0.0
}


Se você já usa C++20, pode preferir requires/constraints, que são mais legíveis:

// arquivo: exemplo5a.cpp (C++20)
#include <type_traits>
#include <iostream>
using namespace std;

template <typename T>
requires std::is_convertible_v<T, double>
double para_double(T&& x) {
    return static_cast<double>(x);
}

template <typename T>
requires (!std::is_convertible_v<T, double>)
double para_double(T&&) {
    return 0.0;
}

int main() {
    cout << para_double(42) << "\n";
    cout << para_double(3.14f) << "\n";
    struct X{}; cout << para_double(X{}) << "\n";
}

6) Transformações úteis de tipo: decay, common_type, conditional, make_signed/unsigned, underlying_type

Algumas transformações são tão comuns que ganharam traits próprios:

std::decay_t faz o que o compilador faz quando você passa T como parâmetro por valor: remove referência, const/volatile, e transforma arrays/funcões em ponteiros para a “coisa”.
std::common_type_t<A,B,...> escolhe um tipo comum (como o que o operador ternário usaria).
std::conditional_t<cond, A, B> escolhe A ou B com base num booleano de tempo de compilação.
std::make_signed_t, std::make_unsigned_t trocam sinal de integrais.
std::underlying_type_t pega o tipo inteiro subjacente do enum.

Exemplo 6 — soma genérica com decay e common_type:

// arquivo: exemplo6.cpp
#include <type_traits>
#include <iostream>
using namespace std;

template <typename A, typename B>
auto soma(A&& a, B&& b) {
    using CA = std::decay_t<A>;
    using CB = std::decay_t<B>;
    using R = std::common_type_t<CA, CB>;
    return static_cast<R>(a) + static_cast<R>(b);
}

int main() {
    cout << soma(1, 2.5) << "\n";     // 3.5
    cout << soma(3u, 4) << "\n";      // 7
}

7) SFINAE com enable_if, void_t e a “detecção de membros”

SFINAE significa “Substitution Failure Is Not An Error”: quando o compilador tenta encaixar um template com um tipo, e algum requisito sobre o tipo não é atendido, aquela sobrecarga simplesmente é descartada, em vez de dar erro.

Ferramentas principais:

std::enable_if_t<cond, T> vira T se cond é true; se false, essa assinatura some.
std::void_t<...> é sempre “void” se todos os ... são válidos; se alguma expressão de tipo falha, aquela especialização “não participa”.

Com void_t construímos a “detecção de membros”, por exemplo: “esse tipo tem um método size()?”

Exemplo 7 — detectando se um tipo tem um typedef value_type:

// arquivo: exemplo7.cpp
#include <type_traits>
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Forma geral: tipo não tem value_type
template <typename, typename = void>
struct tem_value_type : std::false_type {};

// Especialização: existe T::value_type
template <typename T>
struct tem_value_type<T, std::void_t<typename T::value_type>> : std::true_type {};

int main() {
    cout << boolalpha;
    cout << "vector<int>: " << tem_value_type<vector<int>>::value << "\n"; // true
    cout << "string: " << tem_value_type<string>::value << "\n";           // true
    cout << "int: " << tem_value_type<int>::value << "\n";                 // false
}


Exemplo 8 — ativando uma função só se existe “size()”:

// arquivo: exemplo8.cpp
#include <type_traits>
#include <iostream>
#include <vector>
#include <string>
using namespace std;

template <typename, typename = void>
struct has_size_method : std::false_type {};

template <typename T>
struct has_size_method<T, std::void_t<decltype(std::declval<const T&>().size())>>
    : std::true_type {};

template <typename T>
std::enable_if_t<has_size_method<T>::value, size_t>
tamanho(const T& x) {
    return x.size();
}

template <typename T>
std::enable_if_t<!has_size_method<T>::value, size_t>
tamanho(const T&) {
    return 0u;
}

int main() {
    cout << tamanho(string("abc")) << "\n";    // 3
    cout << tamanho(vector<int>{1,2,3,4}) << "\n"; // 4
    cout << tamanho(42) << "\n";               // 0 (não tem size())
}


No C++20, dá para expressar isso com requires/concepts de forma mais natural, mas os traits continuam sendo baseados na mesma ideia.

8) is_invocable, invoke_result: posso chamar isso?

Quando você quer escrever funções que recebem “algo chamável” (um functor, lambda, ponteiro de função), é útil saber em tempo de compilação se é invocável com certos argumentos, e qual seria o tipo de retorno.

std::is_invocable_v<F, Args...>
std::is_invocable_r_v<R, F, Args...> (pede que o retorno seja convertido para R)
std::invoke_result_t<F, Args...> (tipo do retorno se chamar F com Args)

Exemplo 9 — invocação segura com fallback:

// arquivo: exemplo9.cpp
#include <type_traits>
#include <iostream>
#include <string>
#include <utility>
using namespace std;

template <typename F, typename... Args>
auto chama_ou_zero(F&& f, Args&&... args) {
    if constexpr (std::is_invocable_v<F, Args...>) {
        using R = std::invoke_result_t<F, Args...>;
        if constexpr (std::is_convertible_v<R, int>) {
            return static_cast<int>(std::invoke(std::forward<F>(f), std::forward<Args>(args)...));
        } else {
            return 0;
        }
    } else {
        return 0;
    }
}

int main() {
    auto f1 = [](int x){ return x + 1; };
    auto f2 = [](double){ return std::string("oi"); };
    cout << chama_ou_zero(f1, 41) << "\n";   // 42
    cout << chama_ou_zero(f2, 3.14) << "\n"; // não conversível pra int -> 0
    cout << chama_ou_zero(42) << "\n";       // não é chamável -> 0
}

9) Construtores, atribuibilidade, destrutores, “trivial” e “nothrow”

Para escrever tipos e algoritmos eficientes, checar propriedades como “é trivially copyable?” ou “o destrutor é noexcept?” pode orientar decisões importantes.

Alguns traits:

std::is_constructible_v<T, Args...>, std::is_default_constructible_v, std::is_copy_constructible_v, std::is_move_constructible_v
std::is_assignable_v<LHS, RHS>, std::is_copy_assignable_v, std::is_move_assignable_v
std::is_destructible_v, std::is_trivially_destructible_v
std::is_trivially_copyable_v, std::is_trivially_constructible_v<T, Args...>
std::is_nothrow_constructible_v<T, Args...>, std::is_nothrow_move_constructible_v, std::is_nothrow_assignable_v<LHS, RHS>
std::is_swappable_v, std::is_nothrow_swappable_v (requer <type_traits> e, em geral, presente para std::swap via ADL)

Exemplo 10 — escolhendo estratégia de cópia:

// arquivo: exemplo10.cpp
#include <type_traits>
#include <iostream>
#include <vector>
#include <utility>
using namespace std;

template <typename T>
void copia_para(vector<T>& dst, const vector<T>& src) {
    if constexpr (std::is_trivially_copyable_v<T>) {
        // exemplo didático; na prática, você usaria memcpy apenas se coerente e seguro
        dst = src; // assignment já é ótimo; a ideia é mostrar a decisão
        cout << "Copia trivial (simples assignment aqui)\n";
    } else {
        dst.clear();
        dst.reserve(src.size());
        for (const auto& e : src) {
            dst.push_back(e);
        }
        cout << "Copia elemento a elemento\n";
    }
}

struct X {
    int a;
    X() = default;
    X(const X&) { /* cópia não trivial */ }
};

int main() {
    vector<int> a{1,2,3}, b;
    copia_para(b, a);

    vector<X> c(3), d;
    copia_para(d, c);
}

10) Conectivos lógicos prontos: conjunction, disjunction, negation

Combinar várias condições é comum. Você pode usar &&, || dentro de if constexpr, mas os traits oferecem meta-funções que avaliam curto-circuito em tempo de compilação:

std::conjunction<A,B,C...>
std::disjunction<A,B,C...>
std::negation

Eles funcionam com traits “estilo antigo” (os que têm ::value). Nas versões “_v”, você pode simplesmente combinar com operadores lógicos.

Exemplo 11 — habilitando com múltiplas condições:

// arquivo: exemplo11.cpp
#include <type_traits>
#include <iostream>
using namespace std;

template <typename T>
using EhNumeroPequeno =
    std::conjunction<std::is_arithmetic<T>,
                     std::bool_constant<(sizeof(T) <= sizeof(int))>>;

template <typename T>
std::enable_if_t<EhNumeroPequeno<T>::value, int>
f(T x) { return static_cast<int>(x) + 1; }

template <typename T>
std::enable_if_t<!EhNumeroPequeno<T>::value, int>
f(T) { return -1; }

int main() {
    cout << f(short{7}) << "\n";   // 8
    cout << f(3.14) << "\n";       // tipicamente 8, double cabe em int? sizeof(double) costuma ser maior -> -1
}


Se preferir, use if constexpr com operadores lógicos normais — muitas vezes é mais legível.

11) Variants “_t” e “_v” para código mais limpo

Para evitar “::type” e “::value”, use as formas modernas:

std::remove_cv_t, std::invoke_result_t<F,Args...> (tipos)
std::is_integral_v, std::is_same_v<A,B> (valores)

Isso reduz ruído visual e evita erros de digitação com ::type e ::value.

Exemplo 12 — reescrevendo algo mais limpo:

// arquivo: exemplo12.cpp
#include <type_traits>
#include <iostream>
using namespace std;

template <typename T>
void g() {
    using U = std::remove_cvref_t<T>;
    cout << boolalpha << std::is_integral_v<U> << "\n";
}

int main() {
    g<const int&>(); // true
    g<double>();     // false
}

12) Estudos de caso práticos

Agora vamos ver alguns problemas de verdade resolvidos com traits.

Caso A — “serialize” genérico para diferentes tipos

Queremos uma função “escreve” que:

Para numéricos, imprime o valor.
Para enums, imprime o valor subjacente (underlying).
Para strings e coisas parecidas com string, imprime o texto.
Para ponteiros, imprime o endereço (ou “null”).
Para qualquer outra coisa, imprime “”.
// arquivo: exemplo13.cpp
#include <type_traits>
#include <iostream>
#include <string>
#include <typeinfo>
using namespace std;

template <typename E>
constexpr bool eh_enum(E) { return std::is_enum_v<E>; }

template <typename T>
void escreve_impl(const T& x, std::true_type) {
    cout << x;
}

template <typename T>
void escreve_impl(const T& x, std::false_type) {
    cout << "<objeto tipo=" << typeid(T).name() << ">";
}

template <typename T>
void escreve(const T& x) {
    using U = std::remove_cvref_t<T>;
    if constexpr (std::is_arithmetic_v<U>) {
        cout << x;
    } else if constexpr (std::is_enum_v<U>) {
        using Base = std::underlying_type_t<U>;
        cout << static_cast<Base>(x);
    } else if constexpr (std::is_same_v<U, std::string>) {
        cout << x;
    } else if constexpr (std::is_pointer_v<U>) {
        if (x) cout << x; else cout << "null";
    } else {
        escreve_impl(x, std::false_type{});
    }
}

enum Cor { Vermelho=1, Verde=2, Azul=3 };
struct Pessoa { int id; };

int main() {
    escreve(42); cout << "\n";
    escreve(3.14); cout << "\n";
    escreve(std::string("oi")); cout << "\n";
    escreve(Verde); cout << "\n";
    int v=10; escreve(&v); cout << "\n";
    escreve((Pessoa{7})); cout << "\n";
}


Caso B — “reserve_if_possible”: chame reserve(n) apenas se o container tiver esse método

// arquivo: exemplo14.cpp
#include <type_traits>
#include <iostream>
#include <vector>
#include <list>
#include <utility>
using namespace std;

template <typename, typename = void>
struct has_reserve : std::false_type {};

template <typename T>
struct has_reserve<T, std::void_t<decltype(std::declval<T&>().reserve(size_t{}))>> : std::true_type {};

template <typename C>
void reserve_if_possible(C& c, size_t n) {
    if constexpr (has_reserve<C>::value) {
        c.reserve(n);
        cout << "reserve chamado\n";
    } else {
        cout << "sem reserve\n";
    }
}

int main() {
    vector<int> v;
    list<int> l;
    reserve_if_possible(v, 1000); // tem reserve
    reserve_if_possible(l, 1000); // não tem reserve
}


Caso C — Overloads selecionados com enable_if: apenas para integrais

// arquivo: exemplo15.cpp
#include <type_traits>
#include <iostream>
using namespace std;

template <typename T>
std::enable_if_t<std::is_integral_v<T>, T>
duplica(T x) { return x * 2; }

template <typename T>
std::enable_if_t<!std::is_integral_v<T>, T>
duplica(T x) { return x + x; }

int main() {
    cout << duplica(10) << "\n";   // 20
    cout << duplica(1.5) << "\n";  // 3.0
}


Caso D — Checar noexcept/nothrow para escolher estratégia

// arquivo: exemplo16.cpp
#include <type_traits>
#include <iostream>
#include <utility>
using namespace std;

struct A {
    A() noexcept {}
    A(const A&) noexcept {}
};

struct B {
    B() {}
    B(const B&) noexcept(false) {}
};

template <typename T>
T cria() noexcept(std::is_nothrow_default_constructible_v<T>) {
    return T{};
}

template <typename T>
void copia_ou_move(T& dst, const T& src) {
    if constexpr (std::is_nothrow_copy_constructible_v<T>) {
        dst = T(src);
        cout << "copiou sem exceção\n";
    } else if constexpr (std::is_nothrow_move_constructible_v<T>) {
        dst = T(std::move(T(src)));
        cout << "move sem exceção\n";
    } else {
        dst = src;
        cout << "copia normal\n";
    }
}

int main() {
    A a1, a2; copia_ou_move(a1, a2);
    B b1, b2; copia_ou_move(b1, b2);
}

13) Deteção de expressão (idioma detection) mais genérica

Dá para escrever um detector genérico para qualquer expressão usando decltype e void_t. A seguir, um “is_detected” simplificado (versão comum no ecossistema, ainda que não padrão na biblioteca principal):

// arquivo: exemplo17.cpp
#include <type_traits>
#include <iostream>
#include <vector>
#include <string>
using namespace std;

template <class...>
using void_t = void;

template <template<class...> class Op, class, class...>
struct is_detected_impl : std::false_type {};

template <template<class...> class Op, class... Args>
struct is_detected_impl<Op, void_t<Op<Args...>>, Args...> : std::true_type {};

template <template<class...> class Op, class... Args>
using is_detected = is_detected_impl<Op, void, Args...>;

template <class T>
using has_begin_t = decltype(std::declval<T&>().begin());

template <class T>
using has_value_type_t = typename T::value_type;

int main() {
    cout << boolalpha;
    cout << "vector<int> tem begin()? " << is_detected<has_begin_t, vector<int>>::value << "\n";
    cout << "int tem begin()? " << is_detected<has_begin_t, int>::value << "\n";
    cout << "vector<int> tem value_type? " << is_detected<has_value_type_t, vector<int>>::value << "\n";
    cout << "int tem value_type? " << is_detected<has_value_type_t, int>::value << "\n";
}


Com esse padrão, você constrói “conceitos” antes mesmo de ter C++20, e seleciona sobrecargas de acordo com a presença de membros/métodos específicos.

14) Truques com enum, underlying_type e make_signed/unsigned

Enums são comuns, e às vezes precisamos do “tipo base” inteiro para serialização ou interoperabilidade. Também é comum ajustar sinal de um tipo de dado.

Exemplo 18 — imprimir enum como inteiro e alternar sinal de integrais:

// arquivo: exemplo18.cpp
#include <type_traits>
#include <iostream>
using namespace std;

enum class Status : unsigned short { Ok=0, Falha=1 };

template <typename E>
auto enum_para_inteiro(E e) {
    static_assert(std::is_enum_v<E>, "Precisa ser enum");
    using U = std::underlying_type_t<E>;
    return static_cast<U>(e);
}

template <typename T>
void mostra_sinal() {
    using S = std::make_signed_t<T>;
    using U = std::make_unsigned_t<T>;
    cout << "Tamanho S e U: " << sizeof(S) << " " << sizeof(U) << "\n";
}

int main() {
    cout << enum_para_inteiro(Status::Falha) << "\n"; // 1
    mostra_sinal<unsigned int>();
}

15) Dicas de projeto e boas práticas

Prefira as versões “_v” e “_t” dos traits. O código fica muito mais limpo.

Sempre que puder, use if constexpr em vez de especializações complicadas. O código fica mais linear e fácil de ler.

Use static_assert para mensagens claras quando uma condição de tipo for requisito de uso:

static_assert(std::is_arithmetic_v<T>, "T precisa ser numérico");


Para detectar métodos e membros, void_t e decltype(std::declval().algo()) são seus melhores amigos.

Para novas bases de código em C++20, concepts e requires ajudam a expressar intenções de forma direta, mas os type traits continuam necessários para compor as condições.

Evite traits obsoletos como aligned_storage/aligned_union (depreciados). Prefira std::byte, alignas e estruturas modernas.

16) Um mini-projeto integrando vários traits

Vamos construir uma “função de formatação” que recebe qualquer coisa e:

Se for aritmético, imprime com sufixo “[num]”.
Se for string, imprime entre aspas.
Se for enum, imprime o integral subjacente com “[enum]”.
Se for container com begin/end, imprime os elementos com chaves.
Se for ponteiro, imprime endereço ou null.
Se nada disso, imprime “”.
// arquivo: exemplo19.cpp
#include <type_traits>
#include <iostream>
#include <string>
#include <vector>
#include <list>
#include <utility>
#include <typeinfo>
using namespace std;

template <class...> using void_t = void;

template <typename, typename = void>
struct has_begin_end : std::false_type {};

template <typename T>
struct has_begin_end<T, void_t<
    decltype(std::declval<T&>().begin()),
    decltype(std::declval<T&>().end())
>> : std::true_type {};

template <typename T>
void formatar(const T& x);

template <typename It>
void formatar_intervalo(It first, It last) {
    cout << "{";
    bool firstElem = true;
    for (; first != last; ++first) {
        if (!firstElem) cout << ", ";
        formatar(*first);
        firstElem = false;
    }
    cout << "}";
}

template <typename T>
void formatar(const T& x) {
    using U = std::remove_cvref_t<T>;
    if constexpr (std::is_arithmetic_v<U>) {
        cout << x << "[num]";
    } else if constexpr (std::is_same_v<U, std::string>) {
        cout << "\"" << x << "\"";
    } else if constexpr (std::is_enum_v<U>) {
        using Base = std::underlying_type_t<U>;
        cout << static_cast<Base>(x) << "[enum]";
    } else if constexpr (has_begin_end<U>::value) {
        formatar_intervalo(x.begin(), x.end());
    } else if constexpr (std::is_pointer_v<U>) {
        if (x) cout << x; else cout << "null";
    } else {
        cout << "<" << typeid(U).name() << ">";
    }
}

enum Cor { Vermelho=1, Verde=2, Azul=3 };

int main() {
    formatar(10); cout << "\n";
    formatar(std::string("ola")); cout << "\n";
    vector<int> v{1,2,3}; formatar(v); cout << "\n";
    list<string> l{"a","b"}; formatar(l); cout << "\n";
    formatar(Vermelho); cout << "\n";
    int* p = nullptr; formatar(p); cout << "\n";
    struct X{}; formatar(X{}); cout << "\n";
}


Você pode expandir isso fácil: se o tipo tiver método to_string(), preferir ele; se tiver size(), mostrar o tamanho após o container; e assim por diante, sempre usando a técnica de detecção com void_t + decltype.

17) Erros comuns e como evitar
Esquecer de remover referências/const quando faz comparações de tipo: por exemplo, std::is_same_v<T, int> falha se T é const int&. Use remove_cvref_t.
Habilitar e desabilitar função com enable_if em posição errada. Coloque em:
Um parâmetro “fantasma” do template,
Um parâmetro default do template,
O tipo de retorno. O importante é que a expressão depende de T, senão não faz SFINAE e dá erro.
Misturar as bibliotecas: alguns traits (como swappability) interagem com std::swap e ADL. Inclua para declarar std::swap visível. Em geral, incluir <type_traits> e juntos é seguro.
18) Cheatsheet mental rápido

Mesmo evitando listas, vale guardar esta “memória muscular”:

Categoria: is_integral, is_floating_point, is_arithmetic, is_enum, is_class, is_function, is_pointer, is_reference, is_array.
Qualificadores: is_const, is_volatile, remove_cv, remove_reference, remove_cvref.
Relações: is_same, is_base_of, is_convertible, is_constructible, is_assignable.
Invocação: is_invocable, invoke_result.
Construção/atribuição/noexcept/trivial: is_nothrow_..., is_trivially_..., is_destructible.
Transformações: decay, common_type, conditional, make_signed/unsigned, underlying_type, add_/remove_ pointer/ref.
Lógica: conjunction, disjunction, negation.
Detecção: void_t + decltype + declval.

Se você lembrar desse conjunto, você resolve 95% dos problemas com type traits no dia a dia.

Conclusão

A biblioteca <type_traits> é a caixa de ferramentas que permite “pensar sobre tipos” no C++. Você pergunta, descobre e transforma tipos em tempo de compilação, habilita funções quando as condições são atendidas e escreve templates mais robustos, rápidos e fáceis de manter. Vimos como responder “o que é T?”, como combinar condições, como ativar/desativar sobrecargas, como detectar membros e como escolher estratégias de implementação com base em características como trivialidade e noexcept. Também montamos pequenos estudos de caso que você pode adaptar diretamente no seu projeto.

Se quiser, eu preparo a versão estendida com mais de 2000 linhas, contendo:

Versões C++14/C++17/C++20 lado a lado,
Um mini “kit” de detecção genérica reutilizável,
Mais estudos de caso (ex.: serialização leve, formatação configurável, traits para ranges),
Exercícios de fixação com gabarito.

Diga se prefere receber como DOCX ou PDF, que eu gero e envio. Se preferir, posso também dividir em partes aqui no chat.
