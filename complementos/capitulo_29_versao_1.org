* Capítulo 29: Bibliotecas genéricas: elegância vs. usabilidade

O design de uma biblioteca genérica é um exercício de equilíbrio entre dois objetivos que, embora não sejam mutuamente exclusivos, estão frequentemente em tensão. De um lado, temos a elegância: a busca pela abstração máxima, pela pureza matemática e pela ortogonalidade dos componentes, como idealizado por Stepanov na criação da STL. Do outro, temos a usabilidade: o foco na experiência do desenvolvedor, na clareza das mensagens de erro, na simplicidade das interfaces e em uma curva de aprendizado suave.

Uma biblioteca pode ser um triunfo da elegância — perfeitamente abstrata, infinitamente flexível e com performance de custo zero — e, ainda assim, ser um fracasso em usabilidade, tornando-se uma ferramenta apenas para os especialistas que investiram tempo para decifrar suas complexidades. Inversamente, uma biblioteca pode ser extremamente fácil de usar, mas sacrificar a flexibilidade e a performance ao fazer isso. A maestria no design de bibliotecas genéricas modernas reside em encontrar a síntese entre esses dois polos.

** A Elegância Pura e seus Custos

A Biblioteca Padrão de C++ (pré-C++20) é o arquétipo da elegância. Sua arquitetura, baseada na separação entre contêineres, iteradores e algoritmos, é uma obra-prima do design. A capacidade de aplicar std::sort a um std::vector, a um std::deque ou a um array C bruto com a mesma eficiência é um testemunho do poder dessa abstração.

No entanto, essa elegância veio com custos de usabilidade notórios:

  - *Interfaces Verbosas*: O uso de pares de iteradores (container.begin(), container.end()) é a base da flexibilidade da STL, mas para o caso de uso mais comum — operar sobre um contêiner inteiro — é repetitivo e propenso a erros.

  - *Contratos Implícitos*: Como discutimos, os requisitos de um algoritmo sobre um tipo eram implícitos. Para saber por que std::sort não compilava com um std::list, o programador precisava saber que std::sort requer iteradores de acesso aleatório, uma informação que não estava na assinatura da função.

  - *Diagnósticos Terríveis*: A consequência direta dos contratos implícitos eram as mensagens de erro. Uma falha em satisfazer um requisito resultava em uma cascata de falhas de substituição, gerando diagnósticos que podiam ter centenas de linhas e que apontavam para as profundezas da implementação da biblioteca, não para o código do usuário.

Essa era a troca de favores: a biblioteca oferecia poder e performance incomparáveis, mas exigia um alto nível de conhecimento e paciência do programador.

** A Busca pela Usabilidade

Uma biblioteca focada em usabilidade prioriza a experiência do usuário final. Seus princípios de design incluem:

  - *Interfaces Orientadas a Tarefas*: Em vez de expor apenas os blocos de construção mais genéricos, a biblioteca oferece funções que correspondem diretamente às tarefas comuns. sort(my_vector) é mais usável do que std::sort(my_vector.begin(), my_vector.end()).

  - *Padrões Sensatos*: O design baseado em políticas é elegante, mas uma biblioteca usável deve fornecer uma configuração padrão que "simplesmente funciona" para 90% dos casos. O usuário não deveria ser forçado a tomar decisões de design complexas para tarefas simples.

  - *Feedback Imediato e Claro*: O pilar da usabilidade é o diagnóstico. Quando o usuário comete um erro, a biblioteca deve falhar rapidamente e com uma mensagem que explique o problema em termos do código do usuário, não de sua implementação interna.

** C++20: A Grande Síntese

Por muito tempo, designers de bibliotecas tiveram que escolher em que ponto do espectro entre elegância e usabilidade queriam se posicionar. O C++20, mais do que qualquer padrão anterior, forneceu as ferramentas para unir esses dois mundos.

  - *Concepts como Ponte*: Os Concepts são a tecnologia que permite que a elegância seja a usabilidade.
    - Eles tornam os contratos implícitos explícitos, transformando os requisitos de um algoritmo em parte de sua interface. A elegância da abstração agora é auto-documentada.
    - Eles geram erros de compilação precisos e no ponto da chamada. A falha em satisfazer um requisito é diagnosticada de forma clara e imediata.

  - *A Biblioteca de Ranges*: A std::ranges é a primeira grande demonstração dessa síntese na Biblioteca Padrão.
    - *Elegância*: Ela é construída sobre os mesmos princípios abstratos de iteradores e algoritmos, e introduz o conceito funcionalmente elegante de views e composição através do operador |.
    - *Usabilidade*: Ela permite que algoritmos sejam chamados diretamente com contêineres (std::ranges::sort(vec)), eliminando a verbosidade dos pares de iteradores. A composição com | permite que transformações de dados complexas sejam escritas de forma linear e legível.

  #+begin_src cpp
#include <vector>
#include <ranges>
#include <iostream>

int main() {
    std::vector<int> numeros = {5, -1, 4, 0, -3, 2};

    // Pipeline de ranges: elegante e usável.
    // Pega os números, filtra pelos pares, e transforma-os em seus quadrados.
    auto resultado = numeros 
                   | std::views::filter([](int n){ return n % 2 == 0; })
                   | std::views::transform([](int n){ return n * n; });

    for (int n : resultado) {
        std::cout << n << " "; // 16 0 4
    }
    std::cout << std::endl;
    return 0;
}
#+end_src

Este exemplo é, ao mesmo tempo, elegante em sua composição funcional e altamente usável em sua clareza e concisão.

** Conclusão:
A tensão entre elegância e usabilidade não desapareceu, mas o C++ moderno nos deu as ferramentas para gerenciá-la de forma eficaz. O objetivo do designer de bibliotecas genéricas não é mais sacrificar um pelo outro, mas usar os Concepts para impor contratos claros, a std::ranges para criar interfaces fluidas e os padrões de design modernos para fornecer padrões sensatos. A biblioteca ideal é aquela cuja complexidade interna permite uma simplicidade externa, oferecendo um poder imenso através de uma interface que é, ao mesmo tempo, segura, expressiva e agradável de usar.
