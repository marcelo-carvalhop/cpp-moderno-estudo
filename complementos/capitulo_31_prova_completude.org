* Prova da Completude de Turing

O que Erwin Unruh fez, em 1994, é hoje considerado um dos momentos mais surpreendentes da história da linguagem C++: ele demonstrou que o sistema de templates era Turing-complete, ou seja, que o compilador C++ podia, sozinho, realizar qualquer computação possível, sem executar código em tempo de execução — apenas em tempo de compilação.

Vamos destrinchar isso passo a passo, para que você entenda como essa prova funciona e por que ela é tão importante.

** O que significa “Turing-complete”?

Antes de olhar para C++, precisamos entender o conceito em si.

Um sistema é Turing-completo quando ele é capaz de simular uma Máquina de Turing universal, isto é, quando pode expressar qualquer computação que possa ser feita por um computador genérico, desde que haja tempo e memória suficientes.

Para um sistema ser considerado Turing-complete, ele precisa permitir:

  1 . Armazenar estado (ou equivalente);
  2. Executar decisões condicionais (“if”, “else”, etc.);
  3. Executar laços (repetições) — direta ou indiretamente via recursão.

** Templates em C++ antes de 1994

Na época, templates em C++ eram vistos apenas como um mecanismo de generalização de tipos.
Por exemplo:

#+begin_src cpp
template <typename T>
T soma(T a, T b) {
    return a + b;
}
#+end_src

Nada mais do que um gerador de código genérico.
O compilador expandia soma<int> e soma<double>, gerando versões especializadas da função.
Não havia a noção de “cálculo em tempo de compilação”.

** O insight de Erwin Unruh

Unruh percebeu que:

  - Templates podiam instanciar outros templates;
  - Essa instanciação podia depender de parâmetros (números, tipos, etc.);
  - E — crucialmente — isso podia ser recursivo.

Ou seja: ele poderia usar a recursão de templates para simular um loop.

Mais do que isso: ele usou erros de compilação como meio de saída.

Como o compilador precisa imprimir os tipos envolvidos em uma falha, Unruh percebeu que podia codificar o resultado da computação dentro dos nomes de tipos — e o compilador o imprimiria automaticamente.

** A ideia básica do algoritmo

Ele criou algo equivalente a isso (simplificado):

#+begin_src cpp
// Estrutura geral para testar se N é primo dividindo por D
template <int N, int D>
struct IsPrime {
    static const bool value = (N % D != 0) && IsPrime<N, D - 1>::value;
};

// Caso base: quando D == 2
template <int N>
struct IsPrime<N, 2> {
    static const bool value = (N % 2 != 0);
};
#+end_src

Aqui, IsPrime<N, D> chama IsPrime<N, D-1>.
Cada instanciação cria um novo tipo — e, portanto, força o compilador a gerar código recursivamente, descendo até D = 2.

Agora, o truque final:

#+begin_src cpp
template <int N>
struct Primes {
    // Se N é primo, cria um tipo que "força" um erro
    // com o nome do número N visível na mensagem
    Primes<N - 1> next;
    typedef typename std::enable_if<IsPrime<N, N-1>::value, void>::type T;
};
#+end_src

Ao final, o compilador é forçado a instanciar Primes<2>, Primes<3>, Primes<4>... até encontrar algo que cause erro — e na mensagem de erro, aparecem os tipos instanciados:
os números primos.

O “output” do programa não vem do console, mas da mensagem de erro do compilador, que contém o resultado embutido nos nomes dos tipos instanciados.

** 5. Por que isso prova Turing-completeness?

Vamos analisar em termos teóricos.

Para provar que algo é Turing-complete, é suficiente demonstrar que ele possui mecanismos equivalentes a:

  1. Armazenamento de estado → templates armazenam parâmetros inteiros e tipos;
  2. Condicionais → especialização de templates funciona como if;
  3. Recursão → instanciamento recursivo de templates substitui o loop.

Como o sistema de templates de C++ pode representar todos esses três conceitos, ele é capaz de simular qualquer Máquina de Turing.

O programa de Unruh não era só uma brincadeira — era uma prova construtiva: ele mostrou um exemplo concreto de computação não trivial (gerar números primos) sendo feita apenas com recursão de templates e tipos, sem execução em tempo de execução.

** Um exemplo moderno ilustrativo

Veja um exemplo conceitualmente semelhante, mas com sintaxe mais moderna (C++14+):

#+begin_src cpp 
#include <iostream>

// Fatorial em tempo de compilação usando templates
template <int N>
struct Fatorial {
    static constexpr int value = N * Fatorial<N - 1>::value;
};

template <>
struct Fatorial<0> {
    static constexpr int value = 1;
};

int main() {
    std::cout << Fatorial<5>::value << std::endl; // 120
}
#+end_src

Agora, isso ainda é metaprogramação de templates, mas desde C++11 podemos obter o resultado diretamente (sem erro) porque o compilador agora sabe calcular expressões constantes.

Mas no tempo de Unruh, o compilador não tinha constexpr — então ele usou erros de compilação como saída.

** O que essa descoberta causou

O trabalho de Unruh abriu as portas para uma nova subárea da linguagem chamada Template Metaprogramming (TMP) — programação feita dentro do compilador.
A partir disso:

  - Andrei Alexandrescu escreveu Modern C++ Design, introduzindo policy-based design e metaprogramação prática.
  - O projeto Boost.MPL (MetaProgramming Library) formalizou estruturas de dados e algoritmos para serem executados no compilador.
  - E, eventualmente, essas ideias evoluíram para constexpr, concepts, e variadic templates — tornando a metaprogramação mais segura e legível.

** Referências e fontes primárias

Se quiser se aprofundar:

  - Erwin Unruh, “Prime Number Computation During Template Instantiation”, ISO C++ Committee Paper (1994).
  - Andrei Alexandrescu, Modern C++ Design (2001).
  - David Vandevoorde & Nicolai Josuttis, C++ Templates: The Complete Guide (2nd Edition, Addison-Wesley).
  - Boost.MPL e Boost.Hana — exemplos avançados de metaprogramação moderna.
  - CppCon 2014 - Walter E. Brown - “Metaprogramming in C++”.
