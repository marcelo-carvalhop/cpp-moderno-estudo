<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-09-09 Tue 12:11 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Filosofia da Evolução: de 2011 a 2023</title>
<meta name="author" content="Marcelo Carvalho" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Filosofia da Evolução: de 2011 a 2023</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org1262621">1. Capítulo 02: Filosofia da Evolução: de 2011 a 2023</a>
<ul>
<li><a href="#org47b4e9d">1.1. C++11: Como empoderamos o desenvolvedor?</a></li>
<li><a href="#orgd0f22e9">1.2. C++14: Como refinamos a revolução?</a></li>
<li><a href="#orgfd805ff">1.3. C++17: Como enriquecemos a caixa de ferramentas padrão?</a></li>
<li><a href="#org350a05d">1.4. C++20: Como resolvemos os problemas arquiteturais fundamentais?</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org1262621" class="outline-2">
<h2 id="org1262621"><span class="section-number-2">1.</span> Capítulo 02: Filosofia da Evolução: de 2011 a 2023</h2>
<div class="outline-text-2" id="text-1">
<p>
Entre a ratificação do C++98 e a chegada monumental do C++11, a linguagem viveu o que muitos chamam de "A Grande Estagnação". Por mais de uma década, o padrão permaneceu estático, enquanto o mundo do software se movia a uma velocidade vertiginosa. O C++11 não foi, portanto, uma mera atualização; foi uma refundação. Ele marcou o início de uma nova filosofia para a evolução da linguagem, uma filosofia que persiste e se refina até hoje: a de evolução contínua, previsível e orientada por princípios.
</p>

<p>
A mudança mais visível foi a adoção do "modelo de trem". Como documentado por Herb Sutter em seus relatórios do comitê WG21, a comunidade C++ abandonou o ciclo de lançamentos longo e imprevisível em favor de um cronograma regular e disciplinado de um novo padrão a cada três anos. C++11, 14, 17, 20, 23 — cada um é um vagão nesse trem, carregando um conjunto de melhorias testadas e aprovadas. Essa previsibilidade, por si só, mudou a forma como a indústria interage com a linguagem, incentivando a adoção mais rápida de novas funcionalidades.
</p>

<p>
No entanto, a filosofia mais profunda não está no quando, mas no porquê e no como. Apesar da torrente de novas funcionalidades, os princípios fundamentais, articulados por Stroustrup em "The Design and Evolution of C++", permaneceram como a rocha sobre a qual tudo é construído: compatibilidade com C, abstração de custo zero e suporte a múltiplos paradigmas. A evolução moderna não busca substituir esses pilares, mas sim torná-los mais acessíveis, seguros e expressivos.
</p>

<p>
Cada padrão, de 2011 a 2023, pode ser visto como a resposta a um conjunto de perguntas filosóficas:
</p>
</div>
<div id="outline-container-org47b4e9d" class="outline-3">
<h3 id="org47b4e9d"><span class="section-number-3">1.1.</span> C++11: Como empoderamos o desenvolvedor?</h3>
<div class="outline-text-3" id="text-1-1">
<p>
A resposta foi uma renovação completa da experiência de programação. O C++11 buscou eliminar o "trabalho penoso" e tornar o código correto o código mais fácil de escrever. A filosofia era de capacitação em massa.
</p>

<ul class="org-ul">
<li><b>Expressividade</b>: Funções lambda transformaram a maneira como escrevemos algoritmos, substituindo funtores verbosos por lógica concisa e in-loco.</li>
<li><b>Segurança</b>: 'std::unique<sub>ptr</sub>' e 'std::shared<sub>ptr</sub>' tornaram o gerenciamento manual de memória com new e delete um anacronismo. A regra agora era clara: a posse de recursos deve ser automatizada.</li>
<li><b>Performance</b>: A semântica de movimento (move semantics) resolveu o problema crônico de cópias caras e desnecessárias, tornando natural e eficiente passar objetos pesados, como 'std::vector', para dentro e para fora de funções.</li>
<li><b>Concorrência</b>: Pela primeira vez, a linguagem forneceu um modelo de memória e uma biblioteca padrão ('std::thread', 'std::mutex', 'std::atomic') para programação concorrente, reconhecendo que o futuro do hardware era paralelo.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">// Pré-C++11: Verboso e propenso a erros
std::vector&lt;int&gt; v;
v.push_back(1);
v.push_back(2);
// ...
for (std::vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it) {
    std::cout &lt;&lt; *it;
}

// Pós-C++11: Conciso, legível e seguro
std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};
for (int val : v) { // Range-based for
    std::cout &lt;&lt; val;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd0f22e9" class="outline-3">
<h3 id="orgd0f22e9"><span class="section-number-3">1.2.</span> C++14: Como refinamos a revolução?</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Este foi um padrão de "acabamento". A filosofia era de pragmatismo: identificar os pontos ásperos do C++11 e suavizá-los. Foi uma demonstração de que o comitê estava ouvindo o feedback da comunidade. Lambdas genéricas (auto nos parâmetros), relaxamento das restrições de constexpr e dedução de tipo de retorno para funções tornaram o código C++11 ainda mais limpo e poderoso.
</p>
</div>
</div>
<div id="outline-container-orgfd805ff" class="outline-3">
<h3 id="orgfd805ff"><span class="section-number-3">1.3.</span> C++17: Como enriquecemos a caixa de ferramentas padrão?</h3>
<div class="outline-text-3" id="text-1-3">
<p>
A filosofia aqui foi de consolidação. Por anos, desenvolvedores C++ dependeram de bibliotecas externas, como a Boost, para funcionalidades essenciais. O C++17 trouxe muitas dessas ferramentas para a biblioteca padrão, fornecendo soluções robustas e portáveis para problemas comuns.
</p>

<ul class="org-ul">
<li>'std::optional': Para representar valores que podem ou não existir, eliminando o uso de ponteiros nulos ou valores mágicos.</li>
<li>'std::variant': Um union com segurança de tipo.</li>
<li>'std::filesystem': Para manipulação de caminhos, arquivos e diretórios de forma portável.</li>
<li><b>Algoritmos Paralelos</b>: Uma extensão da STL que permite a execução paralela de algoritmos padrão, uma fusão direta da filosofia da programação genérica com a da concorrência.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">// Pré-C++17: Dependente de plataforma e propenso a erros
// #include &lt;sys/stat.h&gt; // E código diferente para Windows...

// Pós-C++17: Limpo, expressivo e portável
#include &lt;filesystem&gt;
#include &lt;iostream&gt;

namespace fs = std::filesystem;

void verificar_arquivo(const fs::path&amp; p) {
    if (fs::exists(p) &amp;&amp; fs::is_regular_file(p)) {
        std::cout &lt;&lt; p &lt;&lt; " existe e tem " &lt;&lt; fs::file_size(p) &lt;&lt; " bytes.\n";
    }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org350a05d" class="outline-3">
<h3 id="org350a05d"><span class="section-number-3">1.4.</span> C++20: Como resolvemos os problemas arquiteturais fundamentais?</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Este foi o padrão mais ambicioso desde o C++11. A filosofia foi atacar problemas de longa data na própria estrutura da linguagem e do processo de compilação.
</p>

<ul class="org-ul">
<li><b>Módulos</b>: A resposta para o problema de décadas dos #includes, projetados para reduzir drasticamente os tempos de compilação e isolar a interface da implementação de forma mais robusta.</li>
<li><b>Conceitos (Concepts)</b>: Uma revolução na programação genérica. Em vez de mensagens de erro de template incompreensíveis, os Conceitos permitem especificar requisitos claros para os tipos usados em templates, diretamente na assinatura da função.</li>
<li><b>Intervalos (Ranges)</b>: Uma reimaginação da STL que permite compor algoritmos de forma mais natural, operando sobre "visões" de dados em vez de pares de iteradores desajeitados.</li>
<li><b>Corrotinas</b>: Uma nova ferramenta fundamental para escrever código assíncrono de forma sequencial e legível.</li>
</ul>

<div class="org-src-container">
<pre class="src src-cpp">// Pré-C++20 (Ranges): Composição difícil
std::vector&lt;int&gt; v = {1, 2, 3, 4, 5, 6};
std::vector&lt;int&gt; pares;
std::copy_if(v.begin(), v.end(), std::back_inserter(pares), 
             [](int i){ return i % 2 == 0; });
std::vector&lt;int&gt; resultado;
std::transform(pares.begin(), pares.end(), std::back_inserter(resultado),
               [](int i){ return i * i; });

// Pós-C++20 (Ranges): Composição declarativa
#include &lt;ranges&gt;
auto resultado_ranges = v | std::views::filter([](int i){ return i % 2 == 0; })
                          | std::views::transform([](int i){ return i * i; });
</pre>
</div>

<p>
<b>C++23 e Além</b>: A filosofia atual é de refinamento contínuo e de preenchimento de lacunas. 'std::expected' melhora o tratamento de erros, 'std::stacktrace' auxilia na depuração, e a biblioteca de Ranges continua a se expandir.
</p>

<p>
A jornada de 2011 a 2023 não é uma coleção aleatória de funcionalidades. É a história de uma comunidade global, guiada pelo comitê WG21, aplicando um conjunto consistente de princípios para evoluir uma das linguagens de programação mais importantes do mundo. É uma filosofia que equilibra o poder bruto com a segurança, a performance com a expressividade e a inovação com a estabilidade. Entender essa filosofia é entender a alma do C++ moderno.
</p>


<p>
<b>Letirua Complementar</b>
<a href="../complementos/capítulo_2_complemento.html">Capítulo 2: Filosofia da Evolução: de 2011 a 2023 (Enriquecido)</a>
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Marcelo Carvalho</p>
<p class="date">Created: 2025-09-09 Tue 12:11</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
