* Capítulo 51: Gerenciamento explícito de dependências

Uma das características que distinguem uma arquitetura robusta de um sistema frágil é a forma como as dependências são gerenciadas. O gerenciamento explícito de dependências é um princípio de design que dita que as colaborações de um componente ou classe (suas dependências) devem ser explícitas, visíveis e fornecidas a ele por uma entidade externa. Em suma, um objeto não deve ser responsável por criar ou localizar suas próprias dependências; ele deve pedir por elas.

Esta abordagem contrasta fortemente com padrões que ocultam dependências, como o uso de Singletons ou Service Locators, que criam um acoplamento forte e implícito, tornando o sistema mais difícil de testar, entender e manter.

** 51.1 O Antagonista: Dependências Ocultas e o Acoplamento Implícito

Dependências ocultas são a principal fonte de "peso" lógico em um sistema. Elas criam conexões invisíveis entre partes do código que, na superfície, parecem não relacionadas.

*Exemplo 1: O Singleton como Dependência Oculta*
O padrão Singleton, que garante uma única instância de uma classe, é frequentemente usado para serviços globais como loggers ou gerenciadores de configuração.

#+begin_src cpp
// logger_singleton.h
class Logger {
public:
    static Logger& getInstance() {
        static Logger instance;
        return instance;
    }
    void log(const std::string& msg) { /* ... */ }
private:
    Logger() = default;
    // ... proibir cópia e movimento
};

// processador_de_pedidos.cpp
#include "logger_singleton.h"

class ProcessadorDePedidos {
public:
    void processar(int pedidoId) {
        // ... lógica ...
        if (erro) {
            // A dependência do Logger está oculta aqui dentro.
            Logger::getInstance().log("Erro no pedido " + std::to_string(pedidoId));
        }
    }
};
#+end_src

Os problemas desta abordagem são severos:

    - *Intestável*: Como você pode testar ~ProcessadorDePedidos~ de forma isolada? Ele está permanentemente acoplado à implementação concreta do Logger. Você não pode substituí-lo por um "mock logger" em um teste unitário para verificar se a função de log foi chamada. O teste agora depende do sistema de arquivos ou da rede, transformando-se em um teste de integração.

    - *Acoplamento Forte*: ~ProcessadorDePedidos~ está acoplado não apenas à interface do Logger, mas à sua política de tempo de vida (ser um singleton).

    - *Falta de Clareza*: A interface pública de ~ProcessadorDePedidos~ (seu construtor e métodos) não dá nenhuma pista de que ele depende de um ~Logger~. A dependência é uma surpresa escondida na implementação.

** 51.2 O Princípio: "Peça o que Você Precisa" (Injeção de Dependência)

A solução é tornar a dependência explícita. A classe deve declarar suas necessidades em sua interface pública, tipicamente através de seu construtor. Esta é a forma mais comum de Injeção de Dependência (Dependency Injection - DI).

*Refatorando para Dependências Explícitas:*
Primeiro, definimos uma interface de abstração para o logger.

#+begin_src cpp
// ilogger.h (Interface)
#pragma once
#include <string>

class ILogger {
public:
    virtual ~ILogger() = default;
    virtual void log(const std::string& msg) = 0;
};
#+end_src

Agora, ProcessadorDePedidos pede um ILogger em seu construtor.
#+begin_src cpp
// processador_de_pedidos.h
#pragma once
#include "ilogger.h" // Depende da abstração, não da implementação

class ProcessadorDePedidos {
public:
    // A dependência é explícita no construtor.
    explicit ProcessadorDePedidos(ILogger& logger);
    void processar(int pedidoId);
private:
    ILogger& logger_; // Armazena uma referência para a dependência.
};

// processador_de_pedidos.cpp
#include "processador_de_pedidos.h"

ProcessadorDePedidos::ProcessadorDePedidos(ILogger& logger) : logger_(logger) {}

void ProcessadorDePedidos::processar(int pedidoId) {
    if (erro) {
        logger_.log("Erro no pedido " + std::to_string(pedidoId));
    }
}
#+end_src

*Os Benefícios Imediatos:*

    1. Testabilidade: Este é o benefício mais importante. Agora podemos testar ProcessadorDePedidos em total isolamento.

    #+begin_src cpp
    // Em um arquivo de teste (e.g., usando Google Test)
    #include "gtest/gtest.h"
    #include "processador_de_pedidos.h"

    // Um "mock" que implementa a interface para fins de teste.
    class MockLogger : public ILogger {
    public:
        void log(const std::string& msg) override {
            ultima_msg = msg;
            foi_chamado = true;
        }
        std::string ultima_msg;
        bool foi_chamado = false;
    };

    TEST(ProcessadorDePedidosTest, LogaErroNaFalha) {
        MockLogger mock_logger;
        ProcessadorDePedidos processador(mock_logger);

        // Simula uma condição de erro
        processador.processarComErro(123);

        ASSERT_TRUE(mock_logger.foi_chamado);
        ASSERT_EQ(mock_logger.ultima_msg, "Erro no pedido 123");
    }
    #+end_src 
    
    2. *Clareza e Honestidade*: O construtor de ProcessadorDePedidos agora funciona como um "manifesto". Ele declara claramente: "Para que eu possa funcionar, preciso de algo que se comporte como um ILogger". Não há surpresas.

    3. *Flexibilidade e Reusabilidade*: ~ProcessadorDePedidos~ não sabe nem se importa se o logger escreve para um console, um arquivo ou um serviço de nuvem. Ele pode ser reutilizado em diferentes ambientes simplesmente injetando uma implementação de logger diferente.

** 51.3 Dependências no Nível do Componente

O princípio se estende naturalmente das classes para os componentes. O "contrato" de um componente não é apenas sua API em C++, mas também a lista de outros componentes dos quais ele depende.

Sistemas de build modernos, como o CMake, são projetados para gerenciar isso explicitamente.

#+begin_src cmake
# Em CMakeLists.txt do componente 'processador'

# Declara que o alvo 'processador' precisa dos cabeçalhos
# públicos do alvo 'logger_interface'.
target_link_libraries(processador PRIVATE logger_interface)
#+end_src

Este comando é a manifestação física do gerenciamento explícito de dependências. Ele documenta e impõe a relação entre os componentes. Tentar incluir um cabeçalho de um componente não declarado aqui resultará em um erro de compilação. Isso garante que o grafo de dependências do sistema seja conhecido, validado e mantido de forma limpa.

** Conclusão

O gerenciamento explícito de dependências é uma mudança de mentalidade: de objetos que "pegam" o que precisam para objetos que "recebem" o que precisam. Ao tornar as dependências parte do contrato público de uma classe ou componente, criamos sistemas que são transparentes, modulares e, acima de tudo, testáveis. A injeção de dependências não é um padrão complexo; é a aplicação disciplinada do princípio de que as conexões em um sistema devem ser visíveis e intencionais, nunca acidentais ou ocultas. É a base sobre a qual arquiteturas flexíveis e de longa duração são construídas.
