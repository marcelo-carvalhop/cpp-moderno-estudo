* Capítulo 06: Semântica de Movimento em Arquiteturas Complexas

A introdução da semântica de movimento (move semantics) no C++11 não foi uma melhoria incremental; foi uma mudança de paradigma. Foi a solução para um dos problemas mais antigos e perniciosos da linguagem: o custo proibitivo de mover objetos pesados, como contêineres ou strings, para dentro e para fora de funções. Em arquiteturas de software complexas, onde os dados fluem através de múltiplas camadas de abstração, a semântica de movimento é a engrenagem que permite que esse fluxo ocorra de forma eficiente, transformando operações que antes eram O(n) (copiando cada elemento) em operações O(1) (trocando alguns ponteiros).

Para entender seu impacto, precisamos primeiro dissecar o problema que ela resolve. Antes do C++11, tínhamos apenas a semântica de cópia. Quando um objeto era retornado de uma função ou passado por valor, uma cópia completa era feita.

** O Mundo Pré-C++11: O Custo da Cópia

#+begin_src cpp
#include <iostream>
#include <vector>
#include <string>

std::vector<std::string> gerar_dados_pesados() {
    std::vector<std::string> resultado;
    resultado.reserve(1000);
    for (int i = 0; i < 1000; ++i) {
        resultado.push_back("string_muito_longa_numero_" + std::to_string(i));
    }
    // Ao retornar, 'resultado' é COPIADO para o local de chamada.
    // Isso envolve alocar um novo buffer de memória e copiar 1000 strings.
    // A 'resultado' original é então destruída. Ineficiente.
    return resultado;
}

int main() {
    std::cout << "Iniciando a geração de dados...\n";
    std::vector<std::string> meus_dados = gerar_dados_pesados();
    std::cout << "Dados recebidos. Tamanho: " << meus_dados.size() << "\n";
    return 0;
}
#+end_src

Neste cenário, o retorno de gerar_dados_pesados era uma operação cara. O compilador via que o objeto resultado estava prestes a ser destruído e, mesmo assim, era forçado a fazer uma cópia completa de seus recursos (o buffer de memória alocado dinamicamente) para o objeto meus_dados no main.

* A Revolução: Lvalues, Rvalues e a Referência Rvalue (&&)

A genialidade da solução do C++11 foi introduzir uma nova categoria de valor na linguagem.

  - *Lvalue (locator value)*: Algo que tem um nome e um endereço persistente. Você pode pegar seu endereço. Ex: int x = 5; (x é um lvalue).
  - *Rvalue (right-hand-side value)*: Um valor temporário, anônimo, que está prestes a ser destruído. Você não pode pegar seu endereço. Ex: 5, x + 1, o objeto retornado por gerar_dados_pesados().

A nova peça sintática que tornou isso útil foi a referência rvalue (&&). Ela nos permite criar sobrecargas de funções que se comportam de maneira diferente para lvalues (que precisam ser copiados) e rvalues (cujos recursos podem ser "roubados").
Isso levou à criação de dois novos membros especiais de classe:

  - *Construtor de Movimento ('Move Constructor')*: MinhaClasse(MinhaClasse&& outro)
  - *Operador de Atribuição de Movimento (Move Assignment Operator)*: MinhaClasse& operator=(MinhaClasse&& outro)

Essas funções recebem um rvalue e, em vez de copiarem seus dados, elas pilham seus recursos internos (ponteiros, handles, etc.) e deixam o objeto original (o rvalue) em um estado "vazio", mas válido e destrutível.

** O std::vector Moderno em Ação

O std::vector (e todas as outras classes da STL que gerenciam recursos) foi equipado com um construtor de movimento.

#+begin_src cpp
class VectorSimplificado {
private:
    int* m_dados = nullptr;
    size_t m_tamanho = 0;

public:
    // ... construtor, destrutor, etc. ...

    // Construtor de Cópia (caro)
    VectorSimplificado(const VectorSimplificado& outro) {
        m_tamanho = outro.m_tamanho;
        m_dados = new int[m_tamanho]; // Aloca nova memória
        std::copy(outro.m_dados, outro.m_dados + m_tamanho, m_dados); // Copia os dados
        std::cout << "Construtor de Cópia chamado.\n";
    }

    // Construtor de Movimento (barato)
    VectorSimplificado(VectorSimplificado&& outro) noexcept {
        // 1. Rouba os recursos do outro objeto
        m_dados = outro.m_dados;
        m_tamanho = outro.m_tamanho;
        std::cout << "Construtor de Movimento chamado.\n";

        // 2. Deixa o outro objeto em um estado vazio e seguro
        outro.m_dados = nullptr;
        outro.m_tamanho = 0;
    }
    // ... operadores de atribuição ...
};
#+end_src

Agora, quando o compilador vê return resultado; em gerar_dados_pesados, ele sabe que resultado é um lvalue prestes a expirar. Ele o trata como um rvalue e seleciona automaticamente o construtor de movimento para inicializar meus_dados. A operação se torna uma troca de ponteiros, uma operação O(1).

** std::move: A Ferramenta para Expressar a Intenção de Mover

E se quisermos mover de um lvalue que não está prestes a expirar? É para isso que serve std::move. Contrariamente ao seu nome, std::move não move nada. É um cast condicional. Ele simplesmente diz ao compilador: "Trate este lvalue como se fosse um rvalue. Eu sei o que estou fazendo e não vou usá-lo novamente, exceto para destruí-lo ou reatribuí-lo."

#+begin_src cpp
#include <iostream>
#include <vector>
#include <string>

void consumir_dados(std::vector<std::string> dados) {
    std::cout << "Consumindo " << dados.size() << " strings.\n";
    // ...
}

int main() {
    std::vector<std::string> v1 = {"a", "b", "c"};
    
    // std::vector<std::string> v2 = v1; // Cópia: v1 permanece intacto.

    // Movimento explícito:
    // "Eu não preciso mais do conteúdo de v1, pode ser movido para v2."
    std::vector<std::string> v2 = std::move(v1); 

    std::cout << "Tamanho de v1 após o move: " << v1.size() << "\n"; // Geralmente 0
    std::cout << "Tamanho de v2: " << v2.size() << "\n"; // 3

    // Passando para uma função por valor, que agora pode ser otimizada com move.
    consumir_dados(std::move(v2));
    
    return 0;
}
#+end_src

A saída mostrará que v1 fica "vazio" após o move, pois seus recursos foram pilhados por v2.

** Impacto em Arquiteturas Complexas

Em sistemas com múltiplas camadas (ex: camada de dados -> camada de lógica de negócios -> camada de apresentação), os objetos de dados precisam ser passados entre essas fronteiras. A semântica de movimento garante que esse "passa-mão" de dados seja quase gratuito. É a base para o padrão "sink", onde uma função aceita um parâmetro por valor para indicar que ela tomará posse do recurso, permitindo que o chamador decida se quer copiar ou mover.

#+begin_src cpp
// Uma função "sink" que toma posse do widget.
void processar(Widget w);

WidgetFactory wf;
Widget w1 = wf.criar();

// O chamador pode escolher:
processar(w1);             // Cópia: w1 ainda é válido aqui.
processar(std::move(w1));  // Movimento: w1 não é mais válido aqui.
processar(wf.criar());     // Movimento automático de um temporário (rvalue).
#+end_src

Dominar a semântica de movimento é dominar a gestão de recursos e a performance em C++ moderno. É a diferença entre construir um sistema onde os dados fluem como água através de canos e um onde eles são carregados em baldes, um de cada vez.

*Glóssario*:

[[../complementos/capitulo_6_movimento.org][Semântica de Movimento]]
[[../complementos/capitulo_6_copia.org][Semântica de Cópia]]
[[../complementos/capitulo_6_lvalue.org][Lvalue(locator value)]]
[[../complementos/capitulo_6_rvalue.org][Rvalue (right-hand-side value)]]
[[../complementos/capitulo_6_construtor_movimento.org][Construtor de Movimento]]
[[../complementos/capitulo_6_operador_atribuicao.org][Operador de Atribuição de Movimento]]
[[../complementos/capitulo_6_cast_condicional.org][Cast Condicional]]
[[../complementos/capitulo_6_arquiteturas_complexas.org][Arquiteturas Complexas]]
[[../complementos/capitulo_6_sink.org][Padrão "sink"]]

*Leitura Complementar*:

[[../complementos/capitulo_5_conceito_rvalue.org][O Conceito de Rvalue no C++]]
[[../complementos/capitulo_5_conceito_lvalue.org][O Conceito de Lvalue no c++]]
