* Capítulo 27: Idioma tag dispatching

Na programação genérica, um desafio comum é a necessidade de variar a implementação de um algoritmo com base nas propriedades de um tipo, e não no tipo em si. Por exemplo, o algoritmo std::advance precisa mover um iterador n posições. A maneira mais eficiente de fazer isso depende fundamentalmente da categoria do iterador: para um iterador de acesso aleatório (como o de std::vector), a operação é it += n, um passo de tempo constante. Para um iterador bidirecional (como o de std::list), a única opção é incrementar o iterador n vezes em um loop, uma operação de tempo linear.

Como uma única função template pode escolher a implementação correta em tempo de compilação? Já vimos que SFINAE, if constexpr e concepts são ferramentas para isso. O tag dispatching é outra técnica poderosa e elegante, um idioma de design clássico que antecede as funcionalidades mais modernas e que continua a ser uma solução limpa e escalável, especialmente no design de bibliotecas.

A ideia central é delegar a decisão a um conjunto de funções sobrecarregadas. Em vez de colocar a lógica de seleção if/else dentro da função principal, nós a usamos para selecionar uma "tag" — uma struct vazia que representa uma propriedade — e passamos um objeto dessa tag para uma função auxiliar. A resolução de sobrecarga do C++ então faz o trabalho de selecionar a implementação correta.

** 27.1 O Padrão em Três Passos

O idioma do tag dispatching segue um padrão consistente e claro:

  1. *Definir as Tags*: Crie um conjunto de structs vazias, onde cada uma representa uma propriedade ou categoria distinta. A biblioteca padrão já faz isso para iteradores com std::random_access_iterator_tag, std::bidirectional_iterator_tag, etc.

#+begin_src cpp
// Tags que representam as categorias de iteradores.
// São structs vazias usadas apenas para carregar informação de tipo.
struct random_access_iterator_tag {};
struct bidirectional_iterator_tag {};
// ... e outras como forward_iterator_tag, etc.
#+end_src

  2. *Implementar Funções Auxiliares Sobrecarregadas*: Escreva as diferentes implementações do seu algoritmo em funções auxiliares (geralmente com o sufixo _impl). Cada uma dessas funções aceita um parâmetro extra: um objeto de uma das tags definidas.
#+begin_src cpp
// Implementação para iteradores de acesso aleatório.
template<typename It>
void advance_impl(It& it, int n, random_access_iterator_tag) {
    std::cout << "Dispatch: Acesso Aleatório (O(1))\n";
    it += n;
}

// Implementação para iteradores bidirecionais.
template<typename It>
void advance_impl(It& it, int n, bidirectional_iterator_tag) {
    std::cout << "Dispatch: Bidirecional (O(n))\n";
    if (n > 0) { while (n-- > 0) ++it; }
    else { while (n++ < 0) --it; }
}
#+end_src

  3. *Criar a Função de Despacho (Dispatcher)*: Esta é a função pública que o usuário chama. Sua única responsabilidade é determinar a propriedade do tipo, criar um objeto da tag correspondente e chamar a função auxiliar, passando a tag.

#+begin_src cpp
#include <iterator> // Para std::iterator_traits

template<typename It>
void meu_advance(It& it, int n) {
    // Usa a metafunção iterator_traits para obter o tipo da categoria.
    using Categoria = typename std::iterator_traits<It>::iterator_category;
    
    // Cria um objeto da tag e chama a função auxiliar.
    // A resolução de sobrecarga seleciona a 'advance_impl' correta.
    advance_impl(it, n, Categoria{});
}
#+end_src

** Exemplo em Ação

Quando o código é colocado em prática, o processo é totalmente resolvido em tempo de compilação.

#+begin_src cpp
#include <iostream>
#include <vector>
#include <list>

// ... (código das tags e das funções advance_impl e meu_advance)

int main() {
    std::vector<int> v = {1, 2, 3, 4, 5};
    auto v_it = v.begin();
    std::cout << "Avançando vector iterator...\n";
    meu_advance(v_it, 2); // O compilador gera uma chamada para advance_impl com random_access_iterator_tag
    std::cout << "Novo valor: " << *v_it << "\n\n"; // 3

    std::list<int> l = {1, 2, 3, 4, 5};
    auto l_it = l.begin();
    std::cout << "Avançando list iterator...\n";
    meu_advance(l_it, 2); // O compilador gera uma chamada para advance_impl com bidirectional_iterator_tag
    std::cout << "Novo valor: " << *l_it << "\n"; // 3
    
    return 0;
}
#+end_src

Não há custo de if ou switch em tempo de execução. O compilador seleciona a implementação correta e pode até mesmo embutir (inline) a chamada, resultando no código mais otimizado possível.

** Tag Dispatching no C++ Moderno

Com a introdução do if constexpr no C++17, muitos casos simples que antes exigiriam tag dispatching podem ser resolvidos de forma mais localizada e talvez mais legível:

#+begin_src cpp
template<typename It>
void meu_advance_cpp17(It& it, int n) {
    using Categoria = typename std::iterator_traits<It>::iterator_category;
    if constexpr (std::is_base_of_v<random_access_iterator_tag, Categoria>) {
        it += n;
    } else {
        if (n > 0) { while (n-- > 0) ++it; }
    }
}
#+end_src

No entanto, o tag dispatching continua a ser um padrão superior quando:

  - *As implementações são complexas*: Se cada _impl tiver dezenas de linhas, separá-las em funções distintas melhora drasticamente a organização e a legibilidade.
  - *A lógica de despacho é extensível*: É mais fácil adicionar uma nova categoria (uma nova tag e uma nova sobrecarga _impl) do que adicionar outra cláusula else if a uma função monolítica.
  - *A clareza é primordial*: O padrão separa claramente a "lógica de decisão" (o dispatcher) da "lógica de ação" (as implementações), o que é um princípio de bom design de software.

** Conclusão:

O tag dispatching é um idioma que encapsula a beleza da programação genérica em C++. Ele combina metafunções (para consultar propriedades de tipos) com a resolução de sobrecarga (para selecionar código) a fim de criar um mecanismo de despacho estático, eficiente e limpo. Embora ferramentas como if constexpr ofereçam uma alternativa mais concisa para casos simples, o tag dispatching permanece um padrão de design fundamental para a construção de bibliotecas genéricas robustas, organizadas e extensíveis.
