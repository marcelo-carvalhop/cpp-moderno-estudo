* Capítulo 29 — Bibliotecas Genéricas: Elegância e Usabilidade

Projetar uma biblioteca genérica em C++ é um exercício de engenharia intelectual. Trata-se de buscar o ponto de equilíbrio entre duas forças que coexistem em tensão permanente: a elegância da abstração e a usabilidade da interface.
A elegância busca o ideal matemático — generalidade, pureza e consistência conceitual. A usabilidade busca a experiência humana — clareza, ergonomia e previsibilidade. Um bom design nasce do diálogo entre essas duas linguagens: a linguagem das máquinas e a linguagem dos programadores.

** A Elegância como Ideia Estrutural

Alexander Stepanov, criador da STL, acreditava que o código deveria ser uma forma de álgebra. A Biblioteca Padrão do C++ é o resultado direto dessa filosofia. Cada componente — contêiner, iterador, algoritmo — é definido de forma independente e combinável, criando um sistema modular e ortogonal. A genialidade dessa estrutura é que os algoritmos não conhecem os tipos concretos com os quais trabalham. O mesmo std::sort pode ordenar um std::vector<int>, um std::deque<float> ou até um array C, sem qualquer perda de eficiência.

Essa separação, porém, cobra um preço. A elegância algébrica implica abstrações de segunda ordem — ou seja, conceitos que descrevem comportamentos de tipos, e não os tipos em si. O compilador precisa deduzir e verificar essas propriedades em tempo de compilação, e quando algo não se encaixa, as mensagens de erro se tornam praticamente indecifráveis.
O C++ anterior a 2020 era um campo fértil para esse tipo de frustração. Um simples erro de tipo podia gerar centenas de linhas de diagnóstico. O programador precisava saber, por exemplo, que std::sort exige um iterador de acesso aleatório; caso contrário, descobriria apenas que “um tipo não satisfaz os requisitos de uma função interna obscura”.

A elegância, portanto, é um ideal que se sustenta sobre uma camada de complexidade oculta. É uma forma de beleza difícil, exigente — como uma obra de arte que só se revela completamente a quem conhece sua gramática interna.

** A Usabilidade como Contraponto Humano

Do outro lado, está a usabilidade, a dimensão pragmática do design de software. Uma biblioteca usável é aquela que acolhe o programador. Ela antecipa erros, comunica intenções e fornece caminhos previsíveis.
A elegância pura vê o programador como um matemático; a usabilidade o vê como um artesão. Em um mundo ideal, ele deve poder construir algo útil sem compreender toda a teoria que o sustenta.

Uma biblioteca focada na experiência do usuário tende a oferecer interfaces diretas, funções nomeadas conforme o domínio da tarefa e diagnósticos claros. Em vez de pedir std::sort(v.begin(), v.end()), ela permite sort(v) — um gesto que expressa intenção, não mecanismo.
A preocupação com mensagens de erro é igualmente fundamental. Um bom design deve falhar de forma pedagógica, apontando a causa no código do usuário, e não em um abismo de templates.

A tensão entre elegância e usabilidade, portanto, não é estética, mas epistemológica: trata-se da distância entre o que a máquina entende e o que o humano compreende.

** O C++20 e a Síntese das Duas Linguagens

Durante décadas, projetar uma biblioteca genérica em C++ significava escolher um lado. Ou você escrevia uma obra de arte conceitual — flexível, performática, mas difícil — ou uma ferramenta pragmática e limitada.
O C++20 alterou esse equilíbrio ao introduzir um mecanismo que literalmente unifica o contrato matemático e a interface humana: os Concepts.

Um concept é uma forma de quantificar propriedades de tipos de maneira declarativa. Ele permite expressar, na própria assinatura da função, quais operações um tipo deve oferecer. Com isso, os requisitos antes implícitos se tornam explícitos.
Quando um programador escreve:

#+begin_src cpp 
template <std::sortable Range>
void ordenar(Range&& r);
#+end_Src

ele comunica não apenas que ordenar é uma função genérica, mas também que Range deve satisfazer o concept std::sortable. O compilador pode, então, validar essa condição antes de tentar instanciar o template, e se ela falhar, a mensagem de erro será curta, localizada e significativa.

Os Concepts transformaram o design genérico em algo legível. Eles são a ponte entre a álgebra e a retórica — entre a lógica formal e a linguagem natural da programação.

** A Biblioteca de Ranges: Elegância e Usabilidade em Ato

A biblioteca de Ranges, introduzida também no C++20, é a demonstração prática dessa nova filosofia. Ela não abandona os fundamentos da STL, mas os reformula em uma sintaxe mais direta e funcional.
Com ela, o programador não precisa mais lidar com pares de iteradores. Pode simplesmente escrever:

#+begin_src cpp
std::ranges::sort(vec);
#+end_src

A função é a mesma, mas a interface é infinitamente mais natural. Os ranges estendem a noção de contêiner para incluir views, objetos leves que representam transformações sobre dados — filtragens, projeções, encadeamentos — sem criar cópias intermediárias.

Por exemplo:

#+begin_src cpp
#include <vector>
#include <ranges>
#include <iostream>

int main() {
    std::vector<int> numeros = {5, -1, 4, 0, -3, 2};

    auto resultado = numeros
                   | std::views::filter([](int n) { return n % 2 == 0; })
                   | std::views::transform([](int n) { return n * n; });

    for (int n : resultado)
        std::cout << n << " ";
}
#+end_src

Este código não apenas é mais curto — ele é mais expressivo. Ele revela o fluxo de dados em uma linha de raciocínio contínua.
A elegância aqui não está em esconder a complexidade, mas em transformá-la em composição. Cada etapa do pipeline é uma função pura, e o operador | torna explícita a sequência de transformações.
É possível até mesmo combinar views de forma preguiçosa, produzindo resultados apenas quando iterados. Trata-se de um triunfo simultâneo de performance e clareza.

** O Papel dos Defaults e da Composição

Um dos erros mais comuns no design genérico é supor que generalidade é o mesmo que liberdade.
Uma biblioteca que exige que o usuário configure cada política, cada traço de tipo, cada parâmetro de template, não é verdadeiramente genérica — é apenas indecidida. A verdadeira generalidade nasce quando há um caminho natural que funciona na maioria dos casos, e possibilidades de extensão quando necessário.

A STL, nesse sentido, foi um exemplo ambíguo: ao mesmo tempo poderosa e hostil. O C++ moderno propõe um modelo mais equilibrado.
As bibliotecas bem projetadas hoje tendem a fornecer “defaults sensatos”: comportamentos padrão que atendem 90% dos casos, enquanto preservam a capacidade de personalização para os 10% restantes. Isso reduz a fricção sem reduzir o poder expressivo.

A arte está em escolher esses defaults com cuidado. Um parâmetro de template adicional pode custar dezenas de segundos de compilação, e uma decisão de interface mal calibrada pode ecoar por décadas em código legado.

** A Nova Ética do Design Genérico

O C++ moderno nos convida a repensar o papel do autor de bibliotecas. Antes, ele era um arquiteto — projetando estruturas de abstração elegantes para um público especializado. Hoje, ele precisa ser também um designer de experiência — alguém que entende que a clareza de uma mensagem de erro pode ser tão importante quanto a eficiência de um laço interno.

As ferramentas contemporâneas — Concepts, Ranges, Deduction Guides, CTAD, e até módulos — permitem que o autor mantenha a pureza estrutural sem abandonar o programador à própria sorte.
O objetivo final não é mais o código mais genérico, nem o mais fácil. É o mais transparente.
Uma biblioteca genérica bem projetada é aquela cuja complexidade é inteiramente visível para o compilador e invisível para o usuário.

**  Conclusão: O Ponto de Equilíbrio

O design de bibliotecas genéricas é, em última instância, um diálogo entre estética e pragmatismo.
A elegância oferece poder e consistência; a usabilidade oferece acesso e clareza. Quando ambas se encontram — quando o rigor conceitual se alia à empatia com o desenvolvedor — surge o que se pode chamar de “engenharia literária”: código que é, ao mesmo tempo, eficiente, correto e belo.

O C++20 não resolveu essa tensão, mas tornou-a produtiva.
Os Concepts deram forma à elegância; os Ranges deram forma à usabilidade.
Juntos, eles ensinaram que a simplicidade não é a ausência de complexidade, mas sua domesticação.
E que, no fim das contas, a verdadeira elegância é permitir que o programador pense menos sobre a linguagem — e mais sobre o problema que quer resolver.

*Leituras Complementares*:

[[../complementos/capitulo_29_versao_1.org][Versao Antiga]]
[[../complementos/capitulo_29_complemento.org][Complemento]]
