* Capítulo 13: Exceções vs. código robusto sem exceções

A gestão de erros é um pilar central no design de software confiável. Em C++, a discussão sobre a melhor abordagem para lidar com falhas operacionais frequentemente se polariza em duas filosofias principais: o uso idiomático do sistema de exceções e o uso de códigos de erro ou tipos de retorno que representam o estado da operação. Esta não é uma escolha meramente sintática; ela reflete visões distintas sobre o fluxo de controle, a robustez e o custo computacional.

** A Filosofia das Exceções: Erros são Excepcionais

Como explorado anteriormente, o mecanismo de try/throw/catch foi projetado com uma premissa fundamental: separar o código da lógica principal ("o caminho feliz") do código de tratamento de erros. A filosofia subjacente é que os erros que impedem uma função de cumprir seu contrato são eventos excepcionais e não devem poluir o fluxo de controle normal.

*Vantagens:*
  - *Limpeza do Código*: A lógica de negócios permanece clara e linear, livre de verificações de erro a cada passo.
  - *Propagação Automática*: Uma exceção não tratada se propaga automaticamente pela pilha de chamadas até que um manipulador (catch) seja encontrado. Isso evita a necessidade de cada função intermediária inspecionar e repassar manualmente um código de erro.
  - *Segurança com RAII*: A garantia de stack unwinding (desenrolar da pilha) assegura que os destrutores de objetos na pilha sejam chamados, tornando o gerenciamento de recursos (memória, locks, arquivos) robusto e automático na presença de erros.
  - *Tipos de Erro Ricos*: Exceções são objetos. Elas podem carregar informações contextuais detalhadas sobre a falha (mensagens, códigos de erro, stack traces), muito além de um simples valor de retorno.

*Desvantagens e Críticas:*
  - *Custo Oculto*: Embora o "caminho feliz" seja frequentemente otimizado para ter custo zero (zero-cost exceptions), o ato de lançar uma exceção é uma operação cara em tempo de execução. Envolve a captura do estado da pilha, a busca por um manipulador e o desenrolar da pilha.
  - *Fluxo de Controle Não-Local*: A propagação automática pode tornar o fluxo de controle difícil de rastrear. Não é imediatamente óbvio, ao ler uma chamada de função, que ela pode transferir o controle para um bloco catch muito distante.
  - *Restrições de Uso*: Exceções são frequentemente desabilitadas ou proibidas em certos domínios, como sistemas embarcados de tempo real crítico ou kernels de sistema operacional, onde o custo e a não-determinismo do lançamento de exceções são inaceitáveis.

** A Filosofia dos Códigos de Erro: Erros são Dados

A abordagem alternativa trata os erros não como eventos excepcionais que alteram o fluxo de controle, mas como um dos possíveis resultados de uma operação. O erro é simplesmente dados que a função retorna.

*Formas Comuns*:
  1. *Códigos de Retorno*: A abordagem clássica do C, onde um valor especial (e.g., -1, nullptr) indica falha. errno é frequentemente usado para fornecer mais detalhes.
  2. *Parâmetros de Saída*: A função retorna um booleano indicando sucesso/falha, e o resultado real ou o objeto de erro é preenchido através de um parâmetro de referência.
  3. *Tipos de Retorno Compostos*: A abordagem moderna e preferida, que utiliza tipos como 'std::optional' (C++17), 'std::expected' (C++23) ou 'std::pair'.

*Exemplo com std::optional (C++17):*
'std::optional<T>' representa um valor que pode ou não estar presente. É ideal para funções que podem falhar, mas onde a razão da falha não é importante.

#+begin_src cpp
#include <iostream>
#include <optional>
#include <string>

std::optional<int> string_para_int(const std::string& s) {
    try {
        return std::stoi(s);
    } catch (const std::invalid_argument&) {
        return std::nullopt; // Retorna um estado "vazio" para indicar falha.
    } catch (const std::out_of_range&) {
        return std::nullopt;
    }
}

int main() {
    if (auto resultado = string_para_int("123")) {
        std::cout << "Sucesso: " << *resultado << "\n";
    } else {
        std::cout << "Falha na conversão.\n";
    }

    if (auto resultado = string_para_int("abc")) {
        std::cout << "Sucesso: " << *resultado << "\n";
    } else {
        std::cout << "Falha na conversão.\n";
    }
    return 0;
}
#+end_src 

*Exemplo com std::expected (C++23)*:
'std::expected<T, E>' é ainda mais poderoso. Ele contém ou um valor de sucesso (T) ou um valor de erro (E), permitindo que a função retorne informações detalhadas sobre a falha.

#+begin_src cpp
// Requer C++23
/*
#include <iostream>
#include <expected>
#include <string>

enum class ErroConversao { Invalido, ForaDoRange };

std::expected<int, ErroConversao> string_para_int_cpp23(const std::string& s) {
    try {
        return std::stoi(s);
    } catch (const std::invalid_argument&) {
        return std::unexpected(ErroConversao::Invalido);
    } catch (const std::out_of_range&) {
        return std::unexpected(ErroConversao::ForaDoRange);
    }
}
*/
#+end_src

*Vantagens*:
  - *Fluxo de Controle Explícito*: O tratamento de erro é local e explícito. O programador é forçado a lidar com o resultado da falha no local da chamada.
  - *Performance*: Retornar um valor, mesmo um struct como 'std::optional', é uma operação de tempo de execução muito mais barata e previsível do que lançar uma exceção.
  - *Universalidade*: Funciona em qualquer ambiente, incluindo aqueles onde as exceções são proibidas.

*Desvantagens*:
  - *Verboso*: Pode levar a um código mais verboso, com verificações if após cada chamada de função que pode falhar.
  - *Fácil de Ignorar*: O programador pode esquecer de verificar o estado de erro, permitindo que o programa continue com dados inválidos (embora tipos como 'std::optional' e 'std::expected' tornem isso mais difícil e explícito).

** A Síntese Moderna: Quando Usar Cada Um

A visão moderna, defendida por muitos na comunidade C++, incluindo Herb Sutter, não é uma escolha de "um ou outro", mas uma abordagem híbrida baseada na natureza do erro:

  - *Use Exceções para Erros de Lógica e Invariantes do Sistema*:
    + Quando uma função não pode cumprir seu contrato fundamental (e.g., um construtor que não pode construir um objeto válido).
    + Para violações de pré-condições que indicam um bug no programa (e.g., 'std::out_of_range').
    + Quando o erro ocorre em uma camada profunda do sistema e o ponto de recuperação está muito acima na pilha de chamadas.

  - Use Tipos de Retorno para Falhas Operacionais Esperadas:
    + Quando a falha é um resultado comum e esperado da operação (e.g., "arquivo não encontrado", "usuário digitou uma senha inválida", "falha na conversão de string").
    + Em APIs públicas onde forçar o chamador a lidar com o erro explicitamente é desejável.
    + Em código onde a performance é crítica e o custo de uma exceção é inaceitável.

A escolha entre exceções e códigos de erro é uma decisão de design fundamental. As exceções são para o inesperado, para falhas que quebram o modelo do programa. Os tipos de retorno de erro são para o esperado, para os resultados alternativos que fazem parte do domínio do problema. Usar cada ferramenta em seu contexto apropriado leva a um código que é, ao mesmo tempo, robusto, legível e performático.

*Leituras complementares*:
[[../complementos/capitulo_13_aprofundamento.org][Contexto Expandido sobre Exceções]]
[[../complementos/capitulo_13_notas_aprofundamento.org][Notas de Aprofundamento]]
[[../antigos/capitulo_33.org][A Mecânica do Lançamento — throw e o Desenrolamento da Pilha]]
[[../antigos/capitulo_34.org][A Arte da Captura — catch e a Hierarquia de Exceções]]
[[../antigos/capitulo_35.org][O Contrato de Segurança — Garantias de Exceção]]
[[../antigos/capitulo_36.org][O Especificador noexcept — Uma Análise Profunda]]
[[../antigos/capitulo_37.org][Além das Exceções — Tratamento de Erros no C++ Moderno]]
