* Capítulo 33: std::integral_constant e a base de tudo

No universo da metaprogramação, onde os tipos são os protagonistas, os valores constantes em tempo de compilação — 5, true, 'c' — desempenham um papel de coadjuvante crucial. Eles servem como parâmetros para templates, controlam a recursão e representam os resultados de cálculos. No entanto, tratar esses valores "nus" pode ser limitante. E se quiséssemos passar um valor e seu tipo juntos, como uma única entidade? E se quiséssemos criar um sistema onde os próprios valores se tornassem tipos, permitindo que participassem de mecanismos como a resolução de sobrecarga?

A resposta para essas questões é uma das ferramentas mais fundamentais e elegantes da biblioteca padrão: std::integral_constant. Embora sua definição seja trivialmente simples, ela é a pedra angular que unifica o tratamento de valores e tipos na metaprogramação, servindo como a base para toda a biblioteca <type_traits>.

** O que é std::integral_constant?

std::integral_constant é uma struct template que encapsula um valor de um tipo integral (como bool, int, char, size_t, etc.) em um tipo. Sua implementação conceitual é a seguinte:

#+begin_src cpp
template<typename T, T v>
struct integral_constant {
    // O valor encapsulado, disponível como um membro estático.
    static constexpr T value = v;

    // O tipo do valor, disponível como um alias de tipo.
    using value_type = T;

    // O próprio tipo da instanciação, útil para herança.
    using type = integral_constant<T, v>;

    // Permite que um objeto do tipo seja convertido de volta para o valor.
    constexpr operator value_type() const noexcept { return value; }

    // Permite chamar um objeto do tipo como uma função para obter o valor.
    // (Adicionado no C++14)
    constexpr value_type operator()() const noexcept { return value; }
};
#+end_src

À primeira vista, isso pode parecer um invólucro excessivamente complicado para um simples valor. No entanto, sua genialidade reside em três transformações que ele realiza:

  1. *Eleva um Valor a um Tipo*: O valor true é apenas um valor. Mas std::integral_constant<bool, true> é um tipo distinto. Isso é transformador. Tipos diferentes podem ser usados para selecionar sobrecargas de funções diferentes, algo que valores puros não podem fazer.
  2. *Associa um Valor ao seu Tipo*: A estrutura agrupa o valor (value) e seu tipo (value_type) em uma única entidade, tornando as metafunções mais robustas e auto-documentadas.
  3. *Fornece uma Interface Uniforme*: Toda constante integral encapsulada por std::integral_constant pode ser consultada da mesma maneira (::value), independentemente de seu tipo subjacente.

** std::true_type e std::false_type: Os Pilares da Lógica

Os usos mais comuns de std::integral_constant são para o tipo bool. A biblioteca padrão fornece dois aliases convenientes para eles:

#+begin_src cpp
using true_type = std::integral_constant<bool, true>;
using false_type = std::integral_constant<bool, false>;
#+end_src

Esses dois tipos são a base de toda a lógica de tempo de compilação. Quase todas as metafunções de predicado na biblioteca <type_traits>, como std::is_pointer, std::is_const, etc., são implementadas para herdar publicamente de std::true_type ou std::false_type.

Por que a herança é usada aqui? Porque ela permite uma técnica poderosa e limpa para o tag dispatching e para a implementação de outras metafunções.

Considere uma metafunção is_void<T>:

#+begin_src cpp
// Implementação interna (simplificada)
template<typename T>
struct is_void_impl : std::false_type {}; // Por padrão, um tipo não é void.

template<>
struct is_void_impl<void> : std::true_type {}; // Especialização para o caso de ser void.

// A metafunção pública
template<typename T>
struct is_void : is_void_impl<T> {};
#+end_src

Como is_void<void> herda de std::true_type, ele herda também o membro static constexpr bool value = true;. Isso evita a necessidade de redefinir o membro value em cada uma das centenas de type traits.

** Usando integral_constant para Dispatching

A capacidade de transformar um valor em um tipo nos permite usar a resolução de sobrecarga para criar um if em tempo de compilação para funções. Este é o idioma do tag dispatching que vimos anteriormente, agora explicado através de sua base fundamental.

Vamos reescrever nosso exemplo de advance usando std::integral_constant para representar a propriedade "é de acesso aleatório".

#+begin_src cpp
#include <iostream>
#include <vector>
#include <list>
#include <iterator>
#include <type_traits>

// Função auxiliar que recebe um 'tag' do tipo std::true_type
template<typename It>
void advance_impl(It& it, int n, std::true_type /* é_acesso_aleatório */) {
    std::cout << "Dispatch: Acesso Aleatório (O(1))\n";
    it += n;
}

// Sobrecarga que recebe um 'tag' do tipo std::false_type
template<typename It>
void advance_impl(It& it, int n, std::false_type /* não_é_acesso_aleatório */) {
    std::cout << "Dispatch: Não-Aleatório (O(n))\n";
    if (n > 0) { while (n-- > 0) ++it; }
}

// Função de despacho principal
template<typename It>
void meu_advance(It& it, int n) {
    // 1. Obter a categoria do iterador
    using Categoria = typename std::iterator_traits<It>::iterator_category;

    // 2. Usar um type trait para verificar a propriedade
    using is_random_access = std::is_base_of<std::random_access_iterator_tag, Categoria>;

    // 3. Criar um objeto do tipo true_type ou false_type e despachar
    advance_impl(it, n, is_random_access{});
}

int main() {
    std::vector<int> v = {1, 2, 3, 4, 5};
    auto v_it = v.begin();
    meu_advance(v_it, 2); // is_random_access será true_type, selecionando a primeira sobrecarga.

    std::list<int> l = {1, 2, 3, 4, 5};
    auto l_it = l.begin();
    meu_advance(l_it, 2); // is_random_access será false_type, selecionando a segunda.
}
#+end_src

Neste exemplo, is_random_access é um tipo que herda de std::true_type ou std::false_type. Ao criar um objeto anônimo is_random_access{}, o compilador usa a resolução de sobrecarga para escolher a advance_impl correta. O if lógico foi transformado em uma seleção de função em tempo de compilação, sem nenhum custo de branching em tempo de execução.

** Conclusão:

std::integral_constant é a ponte que conecta o mundo dos valores ao mundo dos tipos. Ele formaliza a ideia de uma constante de tempo de compilação, encapsulando-a em um tipo com uma interface uniforme. Essa simples struct é o DNA da biblioteca <type_traits>, permitindo que predicados sejam definidos de forma concisa através da herança de std::true_type e std::false_type. Mais profundamente, ao nos permitir transformar um booleano (true/false) em um tipo (true_type/false_type), ele desbloqueia padrões de design poderosos como o tag dispatching, permitindo que a lógica condicional seja resolvida pelo mecanismo de sobrecarga de funções do compilador. É um exemplo perfeito da filosofia do C++: uma abstração pequena, de custo zero, que serve como alicerce para um ecossistema inteiro de funcionalidades de alto nível.
