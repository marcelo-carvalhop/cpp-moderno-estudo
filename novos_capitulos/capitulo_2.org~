* Capítulo 02: Filosofia da Evolução: de 2011 a 2023

Entre a ratificação do C++98 e a chegada monumental do C++11, a linguagem viveu o que muitos chamam de "A Grande Estagnação". Por mais de uma década, o padrão permaneceu estático, enquanto o mundo do software se movia a uma velocidade vertiginosa. O C++11 não foi, portanto, uma mera atualização; foi uma refundação. Ele marcou o início de uma nova filosofia para a evolução da linguagem, uma filosofia que persiste e se refina até hoje: a de evolução contínua, previsível e orientada por princípios.

A mudança mais visível foi a adoção do "modelo de trem". Como documentado por Herb Sutter em seus relatórios do comitê WG21, a comunidade C++ abandonou o ciclo de lançamentos longo e imprevisível em favor de um cronograma regular e disciplinado de um novo padrão a cada três anos. C++11, 14, 17, 20, 23 — cada um é um vagão nesse trem, carregando um conjunto de melhorias testadas e aprovadas. Essa previsibilidade, por si só, mudou a forma como a indústria interage com a linguagem, incentivando a adoção mais rápida de novas funcionalidades.

No entanto, a filosofia mais profunda não está no quando, mas no porquê e no como. Apesar da torrente de novas funcionalidades, os princípios fundamentais, articulados por Stroustrup em "The Design and Evolution of C++", permaneceram como a rocha sobre a qual tudo é construído: compatibilidade com C, abstração de custo zero e suporte a múltiplos paradigmas. A evolução moderna não busca substituir esses pilares, mas sim torná-los mais acessíveis, seguros e expressivos.

Cada padrão, de 2011 a 2023, pode ser visto como a resposta a um conjunto de perguntas filosóficas:

** C++11: Como empoderamos o desenvolvedor?

A resposta foi uma renovação completa da experiência de programação. O C++11 buscou eliminar o "trabalho penoso" e tornar o código correto o código mais fácil de escrever. A filosofia era de capacitação em massa.

  - *Expressividade*: Funções lambda transformaram a maneira como escrevemos algoritmos, substituindo funtores verbosos por lógica concisa e in-loco.
  - *Segurança*: 'std::unique_ptr' e 'std::shared_ptr' tornaram o gerenciamento manual de memória com new e delete um anacronismo. A regra agora era clara: a posse de recursos deve ser automatizada.
  - *Performance*: A semântica de movimento (move semantics) resolveu o problema crônico de cópias caras e desnecessárias, tornando natural e eficiente passar objetos pesados, como 'std::vector', para dentro e para fora de funções.
  - *Concorrência*: Pela primeira vez, a linguagem forneceu um modelo de memória e uma biblioteca padrão ('std::thread', 'std::mutex', 'std::atomic') para programação concorrente, reconhecendo que o futuro do hardware era paralelo.

#+begin_src cpp
// Pré-C++11: Verboso e propenso a erros
std::vector<int> v;
v.push_back(1);
v.push_back(2);
// ...
for (std::vector<int>::iterator it = v.begin(); it != v.end(); ++it) {
    std::cout << *it;
}

// Pós-C++11: Conciso, legível e seguro
std::vector<int> v = {1, 2, 3, 4, 5};
for (int val : v) { // Range-based for
    std::cout << val;
}
#+end_src

** C++14: Como refinamos a revolução?

Este foi um padrão de "acabamento". A filosofia era de pragmatismo: identificar os pontos ásperos do C++11 e suavizá-los. Foi uma demonstração de que o comitê estava ouvindo o feedback da comunidade. Lambdas genéricas (auto nos parâmetros), relaxamento das restrições de constexpr e dedução de tipo de retorno para funções tornaram o código C++11 ainda mais limpo e poderoso.

** C++17: Como enriquecemos a caixa de ferramentas padrão?

A filosofia aqui foi de consolidação. Por anos, desenvolvedores C++ dependeram de bibliotecas externas, como a Boost, para funcionalidades essenciais. O C++17 trouxe muitas dessas ferramentas para a biblioteca padrão, fornecendo soluções robustas e portáveis para problemas comuns.

  - 'std::optional': Para representar valores que podem ou não existir, eliminando o uso de ponteiros nulos ou valores mágicos.
  - 'std::variant': Um union com segurança de tipo.
  - 'std::filesystem': Para manipulação de caminhos, arquivos e diretórios de forma portável.
  - *Algoritmos Paralelos*: Uma extensão da STL que permite a execução paralela de algoritmos padrão, uma fusão direta da filosofia da programação genérica com a da concorrência.

#+begin_src cpp
// Pré-C++17: Dependente de plataforma e propenso a erros
// #include <sys/stat.h> // E código diferente para Windows...

// Pós-C++17: Limpo, expressivo e portável
#include <filesystem>
#include <iostream>

namespace fs = std::filesystem;

void verificar_arquivo(const fs::path& p) {
    if (fs::exists(p) && fs::is_regular_file(p)) {
        std::cout << p << " existe e tem " << fs::file_size(p) << " bytes.\n";
    }
}
#+end_src

** C++20: Como resolvemos os problemas arquiteturais fundamentais?

Este foi o padrão mais ambicioso desde o C++11. A filosofia foi atacar problemas de longa data na própria estrutura da linguagem e do processo de compilação.

  - *Módulos*: A resposta para o problema de décadas dos #includes, projetados para reduzir drasticamente os tempos de compilação e isolar a interface da implementação de forma mais robusta.
  - *Conceitos (Concepts)*: Uma revolução na programação genérica. Em vez de mensagens de erro de template incompreensíveis, os Conceitos permitem especificar requisitos claros para os tipos usados em templates, diretamente na assinatura da função.
  - *Intervalos (Ranges)*: Uma reimaginação da STL que permite compor algoritmos de forma mais natural, operando sobre "visões" de dados em vez de pares de iteradores desajeitados.
  - *Corrotinas*: Uma nova ferramenta fundamental para escrever código assíncrono de forma sequencial e legível.

#+begin_src cpp
// Pré-C++20 (Ranges): Composição difícil
std::vector<int> v = {1, 2, 3, 4, 5, 6};
std::vector<int> pares;
std::copy_if(v.begin(), v.end(), std::back_inserter(pares), 
             [](int i){ return i % 2 == 0; });
std::vector<int> resultado;
std::transform(pares.begin(), pares.end(), std::back_inserter(resultado),
               [](int i){ return i * i; });

// Pós-C++20 (Ranges): Composição declarativa
#include <ranges>
auto resultado_ranges = v | std::views::filter([](int i){ return i % 2 == 0; })
                          | std::views::transform([](int i){ return i * i; });
#+end_src

*C++23 e Além*: A filosofia atual é de refinamento contínuo e de preenchimento de lacunas. 'std::expected' melhora o tratamento de erros, 'std::stacktrace' auxilia na depuração, e a biblioteca de Ranges continua a se expandir.

A jornada de 2011 a 2023 não é uma coleção aleatória de funcionalidades. É a história de uma comunidade global, guiada pelo comitê WG21, aplicando um conjunto consistente de princípios para evoluir uma das linguagens de programação mais importantes do mundo. É uma filosofia que equilibra o poder bruto com a segurança, a performance com a expressividade e a inovação com a estabilidade. Entender essa filosofia é entender a alma do C++ moderno.


*Letirua Complementar*
[[../complementos/capítulo_2_complemento.org][Capítulo 2: Filosofia da Evolução: de 2011 a 2023 (Enriquecido)]]
