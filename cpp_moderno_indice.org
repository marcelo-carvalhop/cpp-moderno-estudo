* Índice

+[[./antigos/capitulo_1_errado.org][Capítulo 1: Introdução ao CPP Moderno]]+

[[./antigos/capitulo_1.org][Capítulo 1: Mergulhando no C++ Moderno: Fundamentos e Filosofia]]

[[./antigos/capitulo_2.org][Capítulo 2: Tipos Fundamentais, Variáveis e Controle de Fluxo: Os Átomos da Lógica]]

[[./antigos/capitulo_3.org][Capítulo 3: A Anatomia dos Dados: Um Mergulho Profundo nos Tipos Primitivos]]

[[./antigos/capitulo_4.org][Capítulo 4: A Realidade Física dos Dados: Alinhamento, Conversões e o Abismo do Indefinido]]

[[./antigos/parada_estrategica.org][Parada Estratégica: Subir ou Descer o Nível?]]

[[./antigos/interludio_1.org][Interlúdio: Um Mapa Para a Maestria — Por Que o Caminho Importa?]]

[[./antigos/capitulo_5.org][Capítulo 5: Funções — A Arte de Organizar a Lógica]]

[[./antigos/capitulo_6.org][Capítulo 6: A Mecânica das Funções — Por Baixo dos Panos]]

+[[./antigos/capitulo_7_errado.org][Capítulo 7: Agregando Dados — A Simplicidade e o Poder das Structs]]+

[[./antigos/capitulo_7.org][Capítulo 7: Definindo Dados e Constantes — Structs, Enums e o Escopo Global]]

[[./antigos/capitulo_8.org][Capítulo 8: Indireção e Memória — Uma Análise de Ponteiros]]

[[./antigos/capitulo_9.org][Capítulo 9: A Arquitetura da Memória e o Gerenciamento Dinâmico]]

+[[./antigos/capitulo_10_errado.org][Capítulo 10: Gerenciamento de Recursos como um Princípio — Ponteiros Inteligentes e a Semântica de Posse]]+

[[./antigos/capitulo_10.org][Capítulo 10: Posse Exclusiva e Gerenciamento de Recursos — Uma Análise de std::unique_ptr]]

[[./antigos/capitulo_11.org][Capítulo 11: Posse Compartilhada e o Ciclo de Vida Colaborativo — std::shared_ptr]]

[[./antigos/capitulo_12.org][Capítulo 12: Observação Não-Proprietária e a Quebra de Ciclos de Referência — std::weak_ptr]]

[[./antigos/capitulo_13.org][Capítulo 13: Manipulação de Tipos e Auto-Referência em Posse Compartilhada]]

[[./antigos/analose_const.org][Análise da Palavra-chave const em Métodos de Membro]]

[[./antigos/virtual_override.org][Análise de virtual e override]]

[[./antigos/capitulo_14.org][Capítulo 14: Interagindo com o Mundo Exterior — Manipulação de Arquivos em C++]]

[[./antigos/topicos_arquivos_teriminou.org][O Tópico de Arquivos Terminou? Não, e Eis o Que Falta:]]

[[./antigos/capitulo_15.org][Capítulo 15: Mecânica Avançada de I/O — Estado, Acesso Aleatório e Performance]]

[[./antigos/capitulo_16.org][Capítulo 16: Construindo Abstrações — A class e o Encapsulamento]]

[[./antigos/capitulo_17.org][Capítulo 17: Hierarquias e Comportamento Dinâmico — Herança e Polimorfismo]]

+[[./antigos/capitulo_18_errado.org][Capítulo 18: Organização de Código — Do Pré-processador aos Módulos do C++20]]+

[[./antigos/capitulo_18.org][Capítulo 18 (Revisado e Aprofundado): Dominando o Modelo Clássico — Headers, Linkagem e o Pré-processador]]

[[./antigos/capitulo_19.org][Capítulo 19: A Arquitetura Moderna — Módulos, Partições e Interfaces]]

[[./antigos/capitulo_20.org][Capítulo 20: Da Linha de Comando à Automação — Construindo Projetos com make e Makefile]]

+[[./antigos/capitulo_21_errado.org][Capítulo 21: A Anatomia de um Projeto CPP Canônico — Estrutura de Diretórios e Filosofia]]+

[[./antigos/capitulo_21.org][Capítulo 21: A Filosofia da Estrutura de Diretórios — Um Blueprint para a Clareza]]

[[./antigos/capitulo_22.org][Capítulo 22: Gerenciamento de Dependências — Construindo Sobre os Ombros de Gigantes]]

[[./antigos/capitulo_23.org][Capítulo 23: A Meta-Programação do Build — Dominando o CMake]]

[[./antigos/capitulo_24.org][Capítulo 24: A Filosofia da STL e a Genialidade dos Iteradores ]]

[[./antigos/capitulo_25.org][Capítulo 25: Contêineres Sequenciais — Gerenciando Coleções Ordenadas]]

[[./antigos/capitulo_26.org][Capítulo 26: Contêineres Associativos — Busca e Recuperação Eficientes]]

[[./antigos/capitulo_27.org][Capítulo 27: O Poder do <algorithm> e a Programação Expressiva]]

[[./antigos/capitulo_28.org][Capítulo 28: A Natureza da Lambda — O Functor Anônimo]]

[[./antigos/capitulo_29.org][Capítulo 29: A Alma da Lambda — Mecânica de Captura em Detalhe]]

[[./antigos/capitulo_30.org][Capítulo 30: Estado e Mutabilidade em Lambdas]]

[[./antigos/capitulo_31.org][Capítulo 31: Lambdas e a Programação Genérica]] 

[[./antigos/capitulo_32.org][Capítulo 32: Padrões de Uso e Técnicas Avançadas com Lambdas]]

[[./antigos/capitulo_33.org][Capítulo 33: A Mecânica do Lançamento — throw e o Desenrolamento da Pilha]]

[[./antigos/capitulo_34.org][Capítulo 34: A Arte da Captura — catch e a Hierarquia de Exceções]]

[[./antigos/capitulo_35.org][Capítulo 35: O Contrato de Segurança — Garantias de Exceção]]

[[./antigos/capitulo_36.org][Capítulo 36: O Especificador noexcept — Uma Análise Profunda]]

[[./antigos/capitulo_37.org][Capítulo 37: Além das Exceções — Tratamento de Erros no C++ Moderno]]

[[./antigos/capitulo_38.org][Capítulo 38: A Regra dos Três — O Paradigma Clássico de Gerenciamento de Recursos]]

[[./antigos/capitulo_39.org][Capítulo 39: A Regra dos Cinco — A Evolução com a Semântica de Movimento (C++11)]]

[[./antigos/capitulo_40.org][Capítulo 40: A Regra do Zero — A Filosofia do C++ Moderno]]

[[./antigos/capitulo_41.org][Capítulo 41: Uma Nuance Final — O Padrão Copy-and-Swap]]

[[./antigos/capitulo_42.org][Capítulo 42: Herança — Construindo Hierarquias de Tipos]]

[[./antigos/capitulo_43.org][Capítulo 43: Polimorfismo — Uma Interface, Múltiplas Formas]]

[[./antigos/capitulo_44.org][Capítulo 44: Classes Abstratas e Interfaces]]

[[./antigos/capitulo_45.org][Capítulo 45: A Regra de Ouro — Destrutores Virtuais]]

[[./antigos/capitulo_bonus.org][Capítulo Bônus: A Arte e os Perigos do cast em C++]]

[[./antigos/capitulo_46.org][Capítulo 46: Introdução às Threads (std::thread)]]

[[./antigos/capitulo_47.org][Capítulo 47: O Perigo — Condições de Corrida e Dados Compartilhados]]

[[./antigos/capitulo_48.org][Capítulo 48: A Solução — Mutexes e Locks para Exclusão Mútua]]

[[./antigos/capitulo_49.org][Capítulo 49: Operações Atômicas (std::atomic)]]

[[./antigos/capitulo_50.org][Capítulo 50: Tarefas e o Futuro (std::async, std::future, std::promise)]]

[[./antigos/capitulo_51.org][Capítulo 51: Testes Expressivos com Catch2 — A Filosofia e a Prática]]

vi[[./antigos/capitulo_52.org][Capítulo 52: Forjando Ferramentas — Construindo um Micro-Framework de Testes]]

[[./antigos/capitulo_53.org][Capítulo 53: Forjando Ferramentas — A Arte da Asserção]]

_______________________________________________________________________________________________________________________________

* Introdução

Este livro não é um guia para aprender C++. Ele não trata do básico da linguagem, nem das boas práticas mais conhecidas que se repetem desde sua criação. O objetivo aqui é outro: explorar C++ como um *instrumento intelectual de engenharia de software*, um espaço onde paradigmas se cruzam — orientação a objetos, programação genérica, metaprogramação, programação funcional e sistemas de baixo nível.

A ideia é levar o leitor além daquilo que já se encontra em guias introdutórios, apresentando a linguagem como um *laboratório de ideias* para arquiteturas modernas, exploração de desempenho, paralelismo e integração em ecossistemas complexos.

Ao longo de mais de cem capítulos, cada seção é organizada em torno de temas que exigem não apenas conhecimento técnico, mas também reflexão sobre *design, manutenção, interoperabilidade e futuro da linguagem*. O livro serve tanto como um mapa para engenheiros experientes que desejam aprofundar seus conhecimentos, quanto como um repositório de ideias para pesquisadores e profissionais que veem no C++ um ponto de encontro entre teoria e prática.

* Estrutura do Livro

** Parte I — A Profundidade da Linguagem

*Motivação*: Revisitar C++ moderno como linguagem de múltiplos paradigmas e entender como decisões de design se refletem em código de alto impacto.

/Capítulos/:

[[./novos_capitulos/capitulo_1.org][01. O C++ além do básico]]

[[./novos_capitulos/capitulo_2.org][02. Filosofia da evolução: de 2011 a 2023]]

[[./novos_capitulos/capitulo_3.org][03. RAII repensado em sistemas modernos]]

[[./novos_capitulos/capitulo_4.org][04. O verdadeiro poder do /auto/]]

[[./novos_capitulos/capitulo_5.org][05. Referências vs. ponteiros: decisões de design]]

[[./novos_capitulos/capitulo_6.org][06. Semântica de movimento em arquiteturas complexas]]

[[./novos_capitulos/capitulo_7.org][07. Forwarding perfeito: quando e por quê]]

[[./novos_capitulos/capitulo_8.org][08. Inicialização moderna: uniform, structured, designated]]

[[./novos_capitulos/capitulo_9.org][09. /constexpr/: programação entre dois mundos]]

[[./novos_capitulos/capitulo_10.org][10. Tipos fortes e segurança semântica]]

[[./novos_capitulos/capitulo_11.org][11. Casting explícito e seus perigos]]

[[./novos_capitulos/capitulo_12.org][12. Namespaces, módulos e fronteiras de sistemas]]

[[./novos_capitulos/capitulo_13.org][13. Exceções vs. código robusto sem exceções]]

[[./novos_capitulos/capitulo_14.org][14. Idiomas escondidos no core da linguagem]]

[[./novos_capitulos/capitulo_15.org][15. Filosofia da complexidade em C++]]

/Leituras complementares/:
*Livros:*
Bjarne Stroustrup — The Design and Evolution of C++
Scott Meyers — Effective Modern C++
Anthony Williams — Professional C++

*Artigos e papers:*
ISO C++ Committee papers (WG21) sobre evolução da linguagem.
Herb Sutter — Trip Reports from WG21 Meetings (publicados regularmente).
Journal of Object Technology: artigos sobre RAII e exception safety.

*Revistas e conferências:*
ACM SIGPLAN Notices (papers sobre semântica e linguagem).
CppCon (talks sobre RAII, move semantics, constexpr).



** Parte II — Templates e Programação Genérica

*Motivação*: Templates não são apenas ferramentas de reuso, mas o alicerce de um estilo de programação.

/Capítulos/:

[[./novos_capitulos/capitulo_16.org][16. Templates como alicerce de arquitetura]]

[[./novos_capitulos/capitulo_17.org][17. Dedução de tipos: o compilador como aliado]]
[./novos_capitulos/capitulo_18.org]18. SFINAE — erros que viram design
[./novos_capitulos/capitulo_19.org]19. Concepts: um novo contrato para C++
[./novos_capitulos/capitulo_20.org]20. Constraints expressivas
[./novos_capitulos/capitulo_21.org]21. Tipos dependentes e contexto de compilação
[./novos_capitulos/capitulo_22.org]22. Especialização de templates: arte e armadilhas
[./novos_capitulos/capitulo_23.org]23. Polimorfismo estático com CRTP
[./novos_capitulos/capitulo_24.org]24. Variadic templates e abstrações poderosas
[./novos_capitulos/capitulo_25.org]25. Templates recursivos: design em cascata
[./novos_capitulos/capitulo_26.org]26. Metafunções e manipulação de tipos
[./novos_capitulos/capitulo_27.org]27. Idioma tag dispatching2
[./novos_capitulos/capitulo_28.org]28. Abstrações genéricas em containers
[./novos_capitulos/capitulo_29.org]29. Bibliotecas genéricas: elegância vs. usabilidade
[./novos_capitulos/capitulo_30.org]30. Templates como linguagem própria

/Leituras complementares/: 
*Livros:*
David Vandevoorde, Nicolai Josuttis, Douglas Gregor — C++ Templates: The Complete Guide
Andrei Alexandrescu — Modern C++ Design
Matthew Austern — Generic Programming and the STL

*Artigos e papers*:
Stepanov & Musser — Generic Programming (artigo seminal, 1989).
Research papers sobre concepts em ACM Transactions on Programming Languages and Systems (TOPLAS).
Eric Niebler — artigos sobre Ranges e design genérico.

*Revistas e conferências*:
Dr. Dobb’s Journal (arquivo de artigos clássicos de templates).
CppNow (palestras sobre concepts, SFINAE e CRTP).


** Parte III — Metaprogramação e Compile-Time Magic

*Motivação*: Transformar o compilador em um “motor de execução” que trabalha antes mesmo do runtime.

/Capítulos/:

31. História da metaprogramação em C++
32. TMP clássico: listas, ifs e recursão
33. std::integral_constant e a base de tudo
34. constexpr em profundidade
35. if constexpr: elegância sem redundância
36. Tipos em tempo de compilação: std::type_identity, decltype
37. Expressões lambda em tempo de compilação
38. Template lambdas e dedução avançada
39. Reflection: presente e futuro
40. Gerando código em tempo de compilação
41. Tabelas e algoritmos constexpr
42. Construção de DSLs internas
43. Biblioteca MPL e seu legado
44. Boost.Hana e metaprogramação moderna
45. Filosofia: programar no compilador

/Leituras complementares/: C++ Template Metaprogramming (Abrahams & Gurtovoy), artigos sobre boost::mpl e std::mp.
*Livros:*
David Abrahams, Aleksey Gurtovoy — C++ Template Metaprogramming
Louis Dionne — artigos sobre Boost.Hana
Jason Turner — C++ Best Practices (capítulos sobre constexpr e compile-time).

*Artigos e papers*:
Eric Niebler — Ranges and Metaprogramming (palestras e artigos).
Papers do WG21 sobre Reflection e Constexpr.
Andrei Alexandrescu — artigos da CUJ (C++ Users Journal) sobre metaprogramação.

*Revistas e conferências:*
ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI).
CppCon e Meeting C++ (talks sobre metaprogramação).

** Parte IV — Arquitetura e Design com C++

*Motivação*: Usar C++ como terreno de experimentação para arquiteturas grandes e resilientes.

/Capítulos/:

46. O peso de um sistema em C++
47. Design orientado a componentes
48. Interfaces robustas em bibliotecas C++
49. Polimorfismo estático vs. dinâmico
50. Padrão pImpl (pointer to implementation)
51. Gerenciamento explícito de dependências
52. Dependency Injection em C++
53. Modelagem com mixins e traits
54. Builders e factories modernos
55. Herança como problema, composição como solução
56. Coesão e acoplamento em sistemas C++
57. APIs seguras e versionáveis
58. Testabilidade em arquiteturas grandes
59. Evolução de bibliotecas internas
60. Manutenibilidade em décadas de código legado

/Leituras complementares/:
*Livros*:

John Lakos — Large-Scale C++ Software Design
John Lakos — Large-Scale C++ Volume I: Process and Architecture
Martin Fowler — Patterns of Enterprise Application Architecture (não é C++-específico, mas aplicável).
Robert C. Martin — Clean Architecture

*Artigos e papers:*
Herb Sutter — Exceptional C++ series (design orientado a exceções e robustez).
IEEE Software — artigos sobre arquitetura de sistemas em C++.
Padrões de projeto revisitados em C++.

*Revistas e conferências:*
IEEE Software
ACM Queue
Palestras de John Lakos em CppCon.


** Parte V — Programação de Baixo Nível e Desempenho

*Motivação*: C++ ainda é a linguagem da fronteira entre hardware e software.

/Capítulos/:

61. A relação íntima com o hardware
62. Ponteiros crus em ecossistema moderno
63. Smart pointers além do óbvio
64. Alocadores customizados em containers
65. placement new e técnicas avançadas
66. Alinhamento de memória e performance
67. Estruturas cache-friendly
68. Vetorização e SIMD em C++
69. Intrinsics e otimizações manuais
70. Inline assembly moderno
71. Benchmarking sério em C++
72. Profiling com ferramentas do compilador
73. Evitando regressões de performance
74. Zero-cost abstractions na prática
75. Filosofia da otimização extrema

/Leituras complementares/: High Performance C++ (Sutter & Alexandrescu), Intel manuals.
*Livros*:

Alexandrescu & Sutter — C++ Coding Standards
Agner Fog — Optimizing Software in C++
Kurt Guntheroth — Optimized C++

*Artigos e papers*:
Intel Developer Manuals (otimizações, vetorização).
Research papers sobre cache-aware data structures (ACM SIGARCH).
Agner Fog — Instruction Tables e microarquitetura.

*Revistas e conferências*:
IEEE Transactions on Computers
HotChips (conference)
CppCon talks sobre alocadores customizados e performance extrema.

** Parte VI — Concorrência e Computação Distribuída

*Motivação*: C++ moderno como ferramenta para lidar com paralelismo e escalabilidade.

/Capítulos/:

76. Concorrência como paradigma inevitável
77. std::thread: o básico que engana
78. Futures, promises e std::async
79. std::mutex e armadilhas de bloqueio
80. Modelos de memória em profundidade
81. Atomicidade e std::atomic
82. Estruturas lock-free e wait-free
83. Paralelismo em STL (std::execution)
84. Produtor-consumidor em C++ moderno
85. Concorrência com tasks
86. Corrotinas e fluxo assíncrono
87. Design de sistemas paralelos em C++
88. Programação distribuída com RPC
89. C++ em sistemas de alta escalabilidade
90. Filosofia: paralelismo como linguagem

/Leituras complementares/:
*Livros*:
Anthony Williams — C++ Concurrency in Action
Maurice Herlihy, Nir Shavit — The Art of Multiprocessor Programming
Andrew Tanenbaum — Distributed Systems

*Artigos e papers*:
Herb Sutter — Writing Lock-Free Code: A Corrected Approach.
Research papers sobre lock-free algorithms (ACM & IEEE).
Papers do WG21 sobre std::atomic e corrotinas.

*Revistas e conferências*:
ACM Transactions on Computer Systems
PPoPP (Symposium on Principles and Practice of Parallel Programming)
Talks CppCon/CppNow sobre corrotinas e std::execution.

** Parte VII — C++ no Ecossistema Moderno

*Motivação*: A linguagem não vive isolada, mas integrada a ecossistemas diversos.

/Capítulos/:

91. C++ como hub de integração
92. ABI e compatibilidade binária
93. Interoperabilidade com C
94. Conversando com Fortran em HPC
95. Python + C++ com Pybind11
96. Rust e C++: rivais ou aliados?
97. Bindings para linguagens de alto nível
98. Embarcados: C++ em microcontroladores
99. Sistemas em tempo real
100. GPU computing com CUDA
101. OpenCL vs. SYCL vs. C++
102. WebAssembly + C++
103. Ferramentas modernas de build (CMake, Meson, Bazel)
104. Análise estática e sanitizers
105. CI/CD aplicado a C++

/Leituras complementares/: 
*Livros*:
Nicolai Josuttis — The C++ Standard Library
Jason Turner — Practical C++
Mark Harris — CUDA by Example
Programming WebAssembly with C++ and Rust

*Artigos e papers*:
LLVM/Clang docs — ABI, linking e interoperabilidade.
Pybind11 documentation.
Papers da Khronos Group sobre SYCL e OpenCL.

*Revistas e conferências*:
ACM Computing Surveys (interoperabilidade e linguagens).
GTC (NVIDIA GPU Technology Conference).
Emscripten/LLVM talks.

** Parte VIII — O Futuro do C++

*Motivação*: Olhar para frente, discutindo tanto a evolução técnica quanto filosófica.

/Capítulos/:

106. C++26: o que vem pela frente
107. Contracts: segurança formal no código
108. Pattern Matching em C++
109. Filosofia da longevidade em software
110. O papel do C++ em um mundo com Rust e Go

/Leituras complementares/:
*Livros*:
Herb Sutter (futuros livros / drafts WG21).
Scott Meyers — More Effective C++ (reflexões que ainda ecoam).
Andrei Alexandrescu — ensaios sobre linguagem e design.

*Artigos e papers*:
WG21 proposals sobre contracts, pattern matching e reflection.
Debates C++ vs. Rust em ACM Queue.
Artigos filosóficos sobre longevidade de software (IEEE).

*Revistas e conferências*:
Communications of the ACM (discussões sobre o futuro das linguagens).
Talks de Bjarne Stroustrup e Herb Sutter em CppCon.
Meeting C++ painéis sobre futuro da linguagem.
