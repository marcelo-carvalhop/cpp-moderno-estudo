* Capítulo 48: A Solução — Mutexes e Locks para Exclusão Mútua

Diante do perigo não-determinístico das condições de corrida, precisamos de um mecanismo que imponha ordem. Precisamos de uma forma de garantir que a sequência de operações "ler-modificar-escrever" em um recurso compartilhado seja executada como uma única unidade indivisível, ou atômica, do ponto de vista das outras threads. O mecanismo fundamental para alcançar isso é a exclusão mútua, e a ferramenta primária para implementá-la em C++ é o std::mutex.

A palavra mutex é uma abreviação de mutual exclusion. Um mutex pode ser imaginado não como uma simples fechadura, mas como um "bastão de revezamento" (como os usados em corridas). Apenas a thread que está segurando o bastão tem permissão para entrar na "pista de corrida" (a seção crítica). Qualquer outra thread que queira entrar deve esperar, bloqueada, até que a thread atual termine seu percurso e devolva o bastão.

** 48.1 std::mutex — O Mecanismo Bruto e Seus Perigos

A classe std::mutex, definida no header <mutex>, é a implementação desse conceito. Ela possui dois estados fundamentais: travado (locked) e destravado (unlocked). Suas duas operações principais são:

  - lock(): A thread que chama lock() tenta adquirir o "bastão".
    - Se o mutex estiver destravado, a thread adquire a trava com sucesso e a execução continua.
    - Se o mutex já estiver travado por outra thread, a thread que chamou lock() é bloqueada. O sistema operacional a coloca em um estado de espera, e ela não consumirá ciclos de CPU até que o mutex seja liberado.
  -
    unlock(): A thread que possui a trava a libera, permitindo que uma das threads que estavam esperando (se houver alguma) possa adquiri-la.

Vamos aplicar isso ao nosso contador problemático:

#+begin_src cpp
  #include <iostream>
  #include <thread>
  #include <vector>
  #include <mutex>

  long long g_contador = 0;
  std::mutex g_mutex; // Um mutex global para proteger nosso contador global.

  void incrementar_um_milhao_de_vezes() {
      for (int i = 0; i < 1000000; ++i) {
          g_mutex.lock(); // Adquire a trava antes de entrar na seção crítica.
          // --- Início da Seção Crítica ---
          g_contador++;
          // --- Fim da Seção Crítica ---
          g_mutex.unlock(); // Libera a trava para que outras threads possam prosseguir.
      }
  }

  int main() {
      std::thread t1(incrementar_um_milhao_de_vezes);
      std::thread t2(incrementar_um_milhao_de_vezes);

      t1.join();
      t2.join();

      std::cout << "Resultado final obtido: " << g_contador << std::endl; // Agora imprime 2000000
  }
#+end_src

Este código agora funciona corretamente. O mutex garante que apenas uma thread por vez possa executar g_contador++, eliminando a condição de corrida.

No entanto, esta abordagem manual é extremamente perigosa e frágil. O que acontece se uma exceção for lançada dentro da seção crítica? O que acontece se a função tiver múltiplos pontos de retorno?

#+begin_src  cpp
  void operacao_perigosa() {
      g_mutex.lock();
      if (condicao_de_erro_1) {
          // ERRO: Retorno antecipado sem liberar o mutex!
          return; 
      }
      fazer_algo_que_pode_lancar_excecao(); // Se lançar, a linha unlock() nunca é alcançada.
      if (condicao_de_erro_2) {
          // ERRO: Outro retorno antecipado.
          return;
      }
      g_mutex.unlock();
  }
#+end_src

Se g_mutex.unlock() não for chamado, o mutex permanecerá travado para sempre. Qualquer outra thread que tente chamar g_mutex.lock() ficará bloqueada indefinidamente, resultando em um deadlock. O programa para de progredir.

** 48.2 RAII ao Resgate: std::lock_guard

Felizmente, já conhecemos o padrão de design C++ que resolve precisamente este tipo de problema: RAII (Resource Acquisition Is Initialization). Um lock de mutex é um recurso que deve ser adquirido e, invariavelmente, liberado.

A biblioteca padrão nos fornece std::lock_guard, um wrapper RAII leve para std::mutex. Seu funcionamento é a personificação da elegância do C++:

  - No construtor: std::lock_guard recebe um mutex e chama lock() nele.
  - No destrutor: std::lock_guard chama unlock() no mutex.

Ao criar um lock_guard na pilha, a linguagem C++ garante que seu destrutor será chamado quando o escopo for encerrado, não importa como — seja por um retorno normal, um break, um continue ou o lançamento de uma exceção.

*A Maneira Correta e Segura de Travar um Mutex:*
#+begin_src cpp
void incrementar_de_forma_segura() {
    for (int i = 0; i < 1000000; ++i) {
        // Cria o lock_guard. O mutex é travado aqui.
        std::lock_guard<std::mutex> guard(g_mutex); 
        
        // --- Seção Crítica ---
        g_contador++;
        
    } // 'guard' sai do escopo aqui. Seu destrutor é chamado, destravando o mutex.
}
#+end_src

Este código é funcionalmente idêntico ao anterior, mas é infinitamente mais robusto. A complexidade do gerenciamento do lock foi abstraída. std::lock_guard deve ser sua ferramenta padrão para travamento de mutex simples.

** 48.3 Flexibilidade e Controle: std::unique_lock

Às vezes, std::lock_guard é muito rígido. Ele trava na construção e destrava na destruição, e nada mais. Para cenários mais complexos, a biblioteca oferece std::unique_lock. Ele também é um wrapper RAII, mas com capacidades adicionais:

  - Pode ser destravado manualmente: Você pode chamar unlock() em um unique_lock antes que ele saia do escopo.
  - É "movível": Assim como std::unique_ptr, a posse da trava pode ser transferida de um unique_lock para outro.
  - Suporta travamento adiado: Você pode criar um unique_lock sem travar o mutex imediatamente.
  - É necessário para variáveis de condição: Como veremos em capítulos futuros, std::unique_lock é essencial para mecanismos de sincronização mais avançados.

*Cenário de Uso: Liberando a Trava Antecipadamente*
Imagine que a seção crítica é apenas uma pequena parte de uma função maior. Manter o mutex travado por toda a duração da função é ineficiente, pois impede que outras threads progridam desnecessariamente.

#+begin_src cpp
void processar_dados() {
    std::unique_lock<std::mutex> lock(g_mutex); // Trava o mutex.
    // --- Início da Seção Crítica ---
    int dado_local = g_dado_compartilhado;
    // --- Fim da Seção Crítica ---
    lock.unlock(); // Libera a trava explicitamente.

    // Agora, podemos fazer um processamento longo e caro com o dado_local
    // sem manter outras threads esperando.
    processamento_caro(dado_local);
}
#+end_src

** 48.4 O Custo da Sincronização

Mutexes resolvem o problema da correção, mas introduzem um custo de performance. Travar e destravar um mutex, mesmo sem competição, não é uma operação gratuita; envolve instruções de hardware especiais e potencialmente chamadas ao sistema operacional.

O verdadeiro custo, no entanto, é a contenção. Quando múltiplas threads tentam adquirir o mesmo mutex simultaneamente, apenas uma prossegue. As outras são forçadas a esperar. Em casos extremos de alta contenção, seu programa multithreaded pode acabar rodando de forma efetivamente serial, perdendo todos os benefícios do paralelismo.

A lição de design é clara: mantenha suas seções críticas o menor e mais rápido possível. Adquira a trava, faça o mínimo de trabalho necessário com os dados compartilhados e libere a trava o mais rápido possível.



|[[./capitulo_49.org][Anterior]]|[[./cpp_moderno_indice.org][Índice]]|[[./capitulo_49.org][Próximo]]|
